<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="使用串口时:
cd /tmp/ejtag-debug/ ./la_ejtag_debug_gpio -t source configs/configs.ls3a5000 在本机上运行时:
cd /path/ejtag-debug/ ./la_ejtag_debug_usb -t source configs/configs.ls3a5000 cpus 查看pc
set 查看通用寄存器及部分csr寄存器, 此时pc停在set时运行的地址.
cont 从set处继续运行
hb addr; cont 断点到addr处, 等待触发断点.
hbls 查看断点
watch data; cont 检测通用寄存器, 当通用寄存器中和data一致时, 断点此处.
watchls 查看数据检测点.
watch data mask; cont 检测通用寄存器, 当通用寄存器中和data一致时, 断点此处. mask可以设置掩码.
d1/d4/d8 addr length 按照1字节, 4字节, 8字节, 依次dump length个addr寄存器中的值.
m1/m4/m8 addr data1 data2&mldr; 按照1字节, 4字节, 8字节, 依次将dataX 写入addr地址.
disas addr length 反汇编addr处开始length长的内容.
csrs d8 num length 从第num个csr寄存器连续读出length个值."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="龙芯lajtag常用技巧"><meta property="og:description" content="使用串口时:
cd /tmp/ejtag-debug/ ./la_ejtag_debug_gpio -t source configs/configs.ls3a5000 在本机上运行时:
cd /path/ejtag-debug/ ./la_ejtag_debug_usb -t source configs/configs.ls3a5000 cpus 查看pc
set 查看通用寄存器及部分csr寄存器, 此时pc停在set时运行的地址.
cont 从set处继续运行
hb addr; cont 断点到addr处, 等待触发断点.
hbls 查看断点
watch data; cont 检测通用寄存器, 当通用寄存器中和data一致时, 断点此处.
watchls 查看数据检测点.
watch data mask; cont 检测通用寄存器, 当通用寄存器中和data一致时, 断点此处. mask可以设置掩码.
d1/d4/d8 addr length 按照1字节, 4字节, 8字节, 依次dump length个addr寄存器中的值.
m1/m4/m8 addr data1 data2&mldr; 按照1字节, 4字节, 8字节, 依次将dataX 写入addr地址.
disas addr length 反汇编addr处开始length长的内容.
csrs d8 num length 从第num个csr寄存器连续读出length个值."><meta property="og:type" content="article"><meta property="og:url" content="https://loonguser.github.io/applications/ejtag/"><meta property="article:section" content="applications"><meta property="article:modified_time" content="2024-04-03T17:47:21+08:00"><title>龙芯lajtag常用技巧 | 龙芯玩机指南</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.f8de3645fe00591b41524aee174e19edd98a22255a2930a0cdc82a94835ba387.css integrity="sha256-+N42Rf4AWRtBUkruF04Z7dmKIiVaKTCgzcgqlINbo4c=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/zh.search.min.e6dbfdad6a4b82ee75ad8c35df9c8e1bf843a5d83fbb590f07ec8e9fd9ceb36d.js integrity="sha256-5tv9rWpLgu51rYw135yOG/hDpdg/u1kPB+yOn9nOs20=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>龙芯玩机指南</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Chinese</a></label><ul><li><a href=https://loonguser.github.io/en/>English</a></li><li><a href=https://loonguser.github.io/ru/>Russian</a></li></ul></li></ul><ul><li><p><a href=/firmware/><strong>固件</strong></a></p><ul><li><a href=/firmware/grub/>Grub编译与调试</a></li><li><a href=/firmware/pmon/>PMON的使用方法</a></li><li><a href=/firmware/uefi/>从UEFI如何启动到系统</a></li><li><a href=/firmware/firmware/>如何更新固件</a></li></ul></li><li><p><a href=/system/><strong>系统</strong></a></p><ul><li><a href=/system/gen_sys_file/>生成系统下的一些文件</a></li><li><a href=/system/systeminfo/>系统下查看一些信息</a></li><li><a href=/system/install_archlinux/>新世界Archlinux系统安装</a></li><li><a href=/system/update_system/>如何更新系统</a></li></ul></li><li><p><a href=/applications/><strong>应用</strong></a></p><ul><li><a href=/applications/blog/>3A6000上搭建hexo博客</a></li><li><a href=/applications/ejtag/ class=active>龙芯lajtag常用技巧</a></li><li><a href=/applications/gogs/>3A6000上搭建gogs</a></li><li><a href=/applications/qemu/>Qemu使用</a></li></ul></li><li><p><a href=/system/><strong>内核</strong></a></p><ul><li><a href=/system/kernel/>内核编译</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>龙芯lajtag常用技巧</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#引言><strong>引言</strong></a></li><li><a href=#ejtag下载><strong>Ejtag下载</strong></a></li><li><a href=#ejtag运行><strong>Ejtag运行</strong></a></li><li><a href=#ejtag使用><strong>Ejtag使用</strong></a></li></ul></li></ul></nav></aside></header><article class=markdown><p>使用串口时:</p><pre tabindex=0><code>cd /tmp/ejtag-debug/
./la_ejtag_debug_gpio -t
source configs/configs.ls3a5000
</code></pre><p>在本机上运行时:</p><pre tabindex=0><code>cd /path/ejtag-debug/
./la_ejtag_debug_usb -t
source configs/configs.ls3a5000
</code></pre><ol><li><p><code>cpus</code> 查看<code>pc</code></p></li><li><p><code>set</code> 查看通用寄存器及部分<code>csr</code>寄存器, 此时<code>pc</code>停在<code>set</code>时运行的地址.</p></li><li><p><code>cont</code> 从<code>set</code>处继续运行</p></li><li><p><code>hb</code> <code>addr</code>; <code>cont</code> 断点到<code>addr</code>处, 等待触发断点.</p></li><li><p><code>hbls</code> 查看断点</p></li><li><p><code>watch</code> <code>data</code>; <code>cont</code> 检测通用寄存器, 当通用寄存器中和<code>data</code>一致时, 断点此处.</p></li><li><p><code>watchls</code> 查看数据检测点.</p></li><li><p><code>watch</code> <code>data</code> <code>mask</code>; <code>cont</code> 检测通用寄存器, 当通用寄存器中和<code>data</code>一致时, 断点此处. <code>mask</code>可以设置掩码.</p></li><li><p><code>d1</code>/<code>d4</code>/<code>d8</code> <code>addr</code> <code>length</code> 按照<code>1</code>字节, <code>4</code>字节, <code>8</code>字节, 依次<code>dump</code> <code>length</code>个<code>addr</code>寄存器中的值.</p></li><li><p><code>m1</code>/<code>m4</code>/<code>m8</code> <code>addr</code> <code>data1</code> <code>data2</code>&mldr; 按照<code>1</code>字节, <code>4</code>字节, <code>8</code>字节, 依次将<code>dataX</code> 写入<code>addr</code>地址.</p></li><li><p><code>disas</code> <code>addr</code> <code>length</code> 反汇编<code>addr</code>处开始<code>length</code>长的内容.</p></li><li><p><code>csrs</code> <code>d8</code> <code>num</code> <code>length</code> 从第<code>num</code>个<code>csr</code>寄存器连续读出<code>length</code>个值.</p></li><li><p><code>csrs</code> <code>m8</code> <code>num</code> <code>data</code> 向第<code>num</code>个<code>csr</code>寄存器写入<code>data</code>.</p></li><li><p><code>gdbserver</code> 远程调试</p></li><li><p><code>spi_program_flash file</code> 烧录flash, 注意需要配合<code>./la_ejtag_debug_usb</code>程序使用.
<img src=/images/ejtag/ejtag.gif alt=烧录flash></p></li></ol><blockquote><p>以下内容来源于：
<a href=https://zhuanlan.zhihu.com/p/368080970>https://zhuanlan.zhihu.com/p/368080970</a></p></blockquote><h2 id=引言><strong>引言</strong>
<a class=anchor href=#%e5%bc%95%e8%a8%80>#</a></h2><p>Ejtag分两个版本，Window版本、Linux版本。此处主要以Linux版本为例进行介绍。</p><h2 id=ejtag下载><strong>Ejtag下载</strong>
<a class=anchor href=#ejtag%e4%b8%8b%e8%bd%bd>#</a></h2><p>下载地址：<strong>
<a href="https://link.zhihu.com/?target=http%3A//ftp.loongnix.org/embedd/ls1b/ejtag/">http://ftp.loongnix.org/embedd/ls1b/ejtag/</a></strong> Linux版本分为龙芯版和X86版本，找到自己使用的版本压缩包如下：</p><p><img src=https://pic3.zhimg.com/v2-5d405c5dae750f65599b6421fbc6e982_b.jpg alt></p><p><img src=https://pic3.zhimg.com/80/v2-5d405c5dae750f65599b6421fbc6e982_720w.webp alt></p><p>点击下载到本地。</p><h2 id=ejtag运行><strong>Ejtag运行</strong>
<a class=anchor href=#ejtag%e8%bf%90%e8%a1%8c>#</a></h2><p>1、下载Ejtag压缩包，解压到指定目录</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># tar  xf  ejtag-debug-mips64-v3.25.19.tar.gz    ./
</span></span></code></pre></div><p>2、使用linux主机root用户权限(必须root或者普通用户sudo)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># cd ejtag-debug/
</span></span><span style=display:flex><span># ./ejtag_debug_usb
</span></span></code></pre></div><p>3、检查连接状态及驱动是否正常的方法如下 a) 将Ejtag的USB口插入主机，出现红蓝灯同时亮，一秒钟之后绿灯熄灭说明硬件连接正常。 b) 输入如下命令测试Ejtag硬件状态是否正常，如jtagled 0绿灯闪烁则正常，jtagled 1绿灯长亮则正常。如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -jtagled 0  #绿灯进行闪烁
</span></span><span style=display:flex><span>cpu0 -jtagled 1  #绿灯长亮
</span></span></code></pre></div><p>c) 输入usblooptest测试Ejtag硬件能及连接状态是否正常，返回“jtag loop test ok”则正常。如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -usblooptest 
</span></span><span style=display:flex><span>jtag loop test ok  #连接状态正常
</span></span></code></pre></div><p>d) 输入usbver命令返回日期，则说明Ejtag硬件及连接状态正常。如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -usbver 
</span></span><span style=display:flex><span>0x20150105   #连接状态正常
</span></span></code></pre></div><p>4、Ejtag端连接板卡 a) 将USB端拔下， b) 板卡为断电模式； c) 将Ejtag接口端的三角号对准板卡上的1脚进行插入。(注意：此步骤一定要插正确，此步插错执行下面的步骤有可能烧坏CPU或者Ejtag调试器) d) 检查连接无误，将USB端口插入主机，板卡上电。连接如下图：</p><p><img src=https://pic1.zhimg.com/v2-16fa8e9edb55c79551a86d23a274dc74_b.jpg alt></p><p><img src=https://pic1.zhimg.com/80/v2-16fa8e9edb55c79551a86d23a274dc74_720w.webp alt></p><p>5、进入Ejtag加载指定的平台配置文件，根据要调试板卡的平台选择不同的配置文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span> #在3A4000平台上使用的配置文件
</span></span><span style=display:flex><span>cpu0 -source configs/config.ls3a4000
</span></span><span style=display:flex><span> #在3A3000平台上使用的配置文件
</span></span><span style=display:flex><span>cpu0 -source configs/config.ls3a3000
</span></span><span style=display:flex><span> #在3A2000平台上使用的配置文件
</span></span><span style=display:flex><span>cpu0 -source configs/config.ls3a2000
</span></span></code></pre></div><h2 id=ejtag使用><strong>Ejtag使用</strong>
<a class=anchor href=#ejtag%e4%bd%bf%e7%94%a8>#</a></h2><p>1、加载配置文件之后可以，采用如下方法确保板卡与主机之间连接正常。 a) 采用cpus命令读取CPU各个核的PC值。正常如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -cpus
</span></span><span style=display:flex><span>#说明主机通过Ejtag能够抓到目前板卡上CPU的运行到的地址。
</span></span><span style=display:flex><span>#cpus
</span></span><span style=display:flex><span>[00] 0xffffffff9fc06030 [00] 0xffffffffbfc06600 [00] 0xffffffffbfc06600 [00] 0xffffffffbfc06600
</span></span></code></pre></div><p>异常如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -cpus
</span></span><span style=display:flex><span>#cpus
</span></span><span style=display:flex><span>[00] 0x00000000 [00] 0x00000000 [00] 0x00000000 [00] 0x00000000   #说明无法访问到板卡上CPU的运行状态。
</span></span></code></pre></div><p>出现异常，请检查前面步骤是否正确或者确认板卡上电启动是否正常。 b)采用set命令读取核上的通用寄存器。正常如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -set
</span></span><span style=display:flex><span>#set
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>zero:0x0 at:0x10c80 v0:0xffffffffbfe001e0 v1:0xffffffffbfe001e0 
</span></span><span style=display:flex><span>a0:0x0 a1:0x40 a2:0xffffffffbfc022b8 a3:0xffffffffffffffff 
</span></span><span style=display:flex><span>t0:0x900010001fe001c0 t1:0x84000000c84 t2:0xffffffffbbd0020c t3:0x400000 
</span></span><span style=display:flex><span>t4:0x0 t5:0x0 t6:0x2c24848100888010 t7:0x81000200008c8c40 
</span></span><span style=display:flex><span>s0:0x30300000 s1:0x0 s2:0x48a0a03812a04408 s3:0x800010a03c80000c 
</span></span><span style=display:flex><span>s4:0xffffffffbfe00000 s5:0x2200804020400908 s6:0x303400905c601904 s7:0x4830092800248640 
</span></span><span style=display:flex><span>t8:0x8060840014aa2620 t9:0xa08828186e9706 k0:0x1c42408808405808 k1:0x4288ca184404101 
</span></span><span style=display:flex><span>gp:0xffffffff8f998000 sp:0xffffffff8f8fc000 s8:0x372002504000604 ra:0xffffffffbfc022b8 
</span></span><span style=display:flex><span>status:0x4000e0 lo:0x0 hi:0x0 badvaddr:0x1634e0124cd64658 
</span></span><span style=display:flex><span>cause:0x40008000 pc:0xffffffffbfc022e8 epc:0x8884c964c0020b4c
</span></span></code></pre></div><p>能够看到通用寄存器目前的状态。 异常如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -set
</span></span><span style=display:flex><span>#set
</span></span></code></pre></div><p>会出现set命令卡住的现象，请检查前面步骤是否正确或者确认板卡上电启动是否正常。 通常使用这两种方法来判断调试过程中的板卡是否能正常上电运行。 2、常用命令 ①　h 查看帮助 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>h [cmd]
</span></span></code></pre></div><p>②　cpus 读取当前CPU各个核运行的地址。通常结合代码反汇编来寻找CPU卡在哪个地方，方便进一步定位问题。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpus [count[,cpubitmap]]
</span></span></code></pre></div><p>③　set 读写CPU的通用寄存器。通过用来判断CPU核是否处于运行状态；从sp/ra/status/cause/pc/epc等寄存器信息来定位板卡异常。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>set [regname|regno] [value]
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -set    #读出所有通用寄存器
</span></span><span style=display:flex><span>cpu0 -set pc #读pc寄存器
</span></span><span style=display:flex><span>cpu0 -set at #读at寄存器
</span></span><span style=display:flex><span>#设置pc的数值是0xffffffffbfc00000
</span></span><span style=display:flex><span>cpu0 -set pc 0xffffffffbfc00000 
</span></span></code></pre></div><p>④　cont 是continue的意思，退出Ejtag状态继续运行。一般常用于set命令停住CPU之后让CPU继续运行。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cont
</span></span></code></pre></div><p>⑤　d1/d4/d8 是dump的意思，读取CPU、设备相关寄存器或者内存地址。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>d1 [addr] [count]             :dump memory (byte)
</span></span><span style=display:flex><span>d4 [addr] [count]             :dump memory (word)
</span></span><span style=display:flex><span>d8 [addr] [count]             :dump memory (double word)
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -d1 0xffffffffbfe00180 0x1 
</span></span><span style=display:flex><span>#d1 0xffffffffbfe00180 0x1
</span></span><span style=display:flex><span>ffffffffbfe00180: 80                                              .
</span></span><span style=display:flex><span>cpu0 -d4 0xffffffffbfe00180 0x1
</span></span><span style=display:flex><span>#d4 0xffffffffbfe00180 0x1
</span></span><span style=display:flex><span>ffffffffbfe00180: ff003180                            .1..
</span></span><span style=display:flex><span>cpu0 -d8 0xffffffffbfe00180 0x1
</span></span><span style=display:flex><span>#d8 0xffffffffbfe00180 0x1
</span></span><span style=display:flex><span>ffffffffbfe00180: 3700ff00ff003180                  .1.....7
</span></span></code></pre></div><p>⑥　m1/m4/m8是modify的意思，改变写入寄存器或者内存地址新的数据。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>m1 [addr]  [value]            :modify memory (byte)
</span></span><span style=display:flex><span>m4 [addr]  [value]            :modify memory (word)
</span></span><span style=display:flex><span>m8 [addr]  [value]            :modify memory (double word)
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu1 -m1 0xffffffffbfe001e0 0x18
</span></span><span style=display:flex><span>#m1 0xffffffffbfe001e0 0x18
</span></span><span style=display:flex><span>cpu1 -d1 0xffffffffbfe001e0 0x1 
</span></span><span style=display:flex><span>#d1 0xffffffffbfe001e0 0x1
</span></span><span style=display:flex><span>ffffffffbfe001e0: 18 
</span></span></code></pre></div><p>m4/m8操作类似。 ⑦　setconfig 设置CPU调试相关的一些配置等。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>setconfig [configname] [val]  :setconfig for command
</span></span></code></pre></div><p>常用参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>core.cpucount  #设置cpu数目
</span></span><span style=display:flex><span>core.cpuno     #设置当前调试的cpu号
</span></span><span style=display:flex><span>core.cpuwidth  #设置cpu的数据宽度
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -setconfig core.cpuno 3
</span></span><span style=display:flex><span>#切换到CPU3上进行调试 
</span></span><span style=display:flex><span>#setconfig core.cpuno 3  
</span></span><span style=display:flex><span>cpu3-
</span></span><span style=display:flex><span>#该设置的快捷指令
</span></span><span style=display:flex><span>cpu3 -cpu 2 
</span></span><span style=display:flex><span>#cpu 2 
</span></span><span style=display:flex><span>#setconfig core.cpuno 2 
</span></span><span style=display:flex><span>cpu2 -
</span></span></code></pre></div><p>⑧　disas 反汇编addr开始的count条指令。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>disas [addr] [count]          :disas memory
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu3 -disas 0xffffffffbfe00180 0x4
</span></span><span style=display:flex><span>#disas 0xffffffffbfe00180 0x10
</span></span><span style=display:flex><span>0xffffffffbfe00180: ff003180 sd zero,12672(t8)
</span></span><span style=display:flex><span>0xffffffffbfe00184: 3700ff00 ori zero,t8,0xff00
</span></span><span style=display:flex><span>0xffffffffbfe00188: 00000780 sll zero,zero,0x1e
</span></span><span style=display:flex><span>0xffffffffbfe0018c: 00000101 0x101
</span></span></code></pre></div><p>⑨　put/fput/sput 上传文件到板卡。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>put filename address [len] [offset], env: put_speed
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -put gzrom.bin 0xffffffff84000000 
</span></span><span style=display:flex><span>#put gzrom.bin 0xffffffff84000000 
</span></span><span style=display:flex><span>pack: 0,time : 2, download_size : 0xac010, download rate=352264 B/S
</span></span><span style=display:flex><span>cpu0 -
</span></span></code></pre></div><p>该命令常用于定位PMON启动过程中拷贝gzrom.bin二进制到内存出现异常时，是由于内存不稳定导致还是flash有问题导致。同时也用于定位内核加载过程中卡死，来确定存储介质接口问题还是内存问题的的判断。 get/fget/sget 从addr开始的内存地址下载size大小内容存在file中。 格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>get filename address size
</span></span></code></pre></div><p>例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -get gzrom.bin.new 0xffffffff84000000  0xac010
</span></span><span style=display:flex><span>#get gzrom.bin.new 0xffffffff84000000  0xac010
</span></span><span style=display:flex><span>time : 7, size : 0xac010, upload rate=100646 B/S
</span></span><span style=display:flex><span>cpu0 -
</span></span></code></pre></div><p>该命令常用于定位系统卡死时，导出log_buf中未存入到硬盘上的dmesg内核日志，便于排查系统卡死之前有没有异常现象记录在内核日志中。 3、Ejtag的应用实例 a) 烧写PMON固件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -source configs/config.ls3a2000
</span></span><span style=display:flex><span>cpu0 -call program_cachelock #烧写3A1000/3A2000 LPC接口的flash
</span></span><span style=display:flex><span>或者：
</span></span><span style=display:flex><span>cpu0 -source configs/config.ls3a4000
</span></span><span style=display:flex><span>cpu0 -call program_cachelock_spi #烧写3A3000/3A4000 SPI接口的flash
</span></span></code></pre></div><p>烧写过程中可能会出现，烧写不成功卡住的情况。通过如下方法进行尝试： ①　在“cpu0 -call program_cachelock”之前关闭看门狗cpu0 -wdt_close，然后进行烧写操作。 ②　在“cpu0 -call program_cachelock”之前先使用set命令停住CPU然后进行烧写操作。 ③　多次尝试均无效果可以更新以下Ejtag的驱动版本试一试。 b)连接gdb定位系统卡死的问题 如果CPU某个核出现卡死的现象 这种情况时无法运行gdbserver的，因此需要屏蔽掉卡死的核。就可以进入gdbserver了。 命令如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu1 -setconfig core.cpuno 0  #切换到核0
</span></span><span style=display:flex><span>cpu0 -setconfig gdbserver.cpubitmap 0xd  #屏蔽掉核1
</span></span><span style=display:flex><span>cpu0 -gdb #启动gdb
</span></span></code></pre></div><p>使用Ejtag中的gdbserver与开发机gdb连接方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>cpu0 -gdbserver  #port 50010
</span></span></code></pre></div><p>开发机端： 进入gdb</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>#gdb
</span></span></code></pre></div><p>链接gdbserver</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>gdb) target remote :50010
</span></span><span style=display:flex><span>Remote debugging using :50010
</span></span></code></pre></div><p>接下来就可以使用gdbserver进行问题定位了。</p><p><strong>想了解更多相关知识请关注公众号。</strong></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/LoongUser/loonguser.github.io/commit/0716e13763926a781c9761866e29f9c8488eb678 title='最后修改者 AydenMeng | April 3, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 3, 2024</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#引言><strong>引言</strong></a></li><li><a href=#ejtag下载><strong>Ejtag下载</strong></a></li><li><a href=#ejtag运行><strong>Ejtag运行</strong></a></li><li><a href=#ejtag使用><strong>Ejtag使用</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>