[{"id":0,"href":"/firmware/","title":"Firmware","section":"","content":" 龙芯固件说明 # 1. 固件名中的信息 # 如在github上发布的固件名:UDK2018_3A5000-7A2000_Desktop_EVB_V4.0.05429-stable202302_dbg.fd\nUDK2018指基于EDK2018版本代码开发.\n3A5000-7A2000_Desktop指适用于3A6000+7A2000的桌面级板卡.\nEVB指是开发板, 通常是龙芯各产品研发早期放出的板卡, 与之相对的有CRB, A2101等, 通常与板卡厂商强相关.\nV4.0.05429-stable202302指版本号, 202302指发布日期:年/月.\ndbg指debug版本, 表示有串口打印信息. 与之相对的是rel(release版本), 即没有串口打印, 启动会较快. 另外还有fastboot等, 表示更快速的启动版本.\n2. 固件更新方法 # 见 如何更新固件\n3. 找到适合的固件 # dmidecode -t 1 根据相关信息查找固件. 不明白的可以找售后咨询.\n4. Q\u0026amp;A # PMON与UEFI有什么区别，分别用在什么场景下？ pmon功能和界面比较简单，方便调试，通常用在嵌入式场景，当然桌面端也支持. uefi功能和界面比较丰富，但调试比较复杂，所以嵌入式场景通常不用，但是bmc等服务器管理软件通常与uefi有强配合，所以uefi通常用在桌面和服务器领域。\n"},{"id":1,"href":"/applications/gogs/","title":"3A6000上搭建gogs","section":"Applications","content":"pacman -S mariadb mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql systemctl start mysql mariadb --initialize-insecure --user=mysql --datadir=\u0026#39;./data\u0026#39; mysql -u root [root@mxd gitrepo]# mysql -u root mysql: Deprecated program name. It will be removed in a future release, use \u0026#39;/usr/bin/mariadb\u0026#39; instead Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 8 Server version: 11.0.2-MariaDB Arch Linux Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. MariaDB [(none)]\u0026gt; create user \u0026#39;gogs\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;passwd\u0026#39;; Query OK, 0 rows affected (0.001 sec) MariaDB [(none)]\u0026gt; select user,host from mysql.user; +-------------+-----------+ | User | Host | +-------------+-----------+ | PUBLIC | | | | localhost | | gogs | localhost | | mariadb.sys | localhost | | mysql | localhost | | root | localhost | | | mxd | +-------------+-----------+ 7 rows in set (0.001 sec) MariaDB [(none)]\u0026gt; CREATE DATABASE gogs; Query OK, 1 row affected (0.000 sec) MariaDB [(none)]\u0026gt; show databases; +--------------------+ | Database | +--------------------+ | gogs | | information_schema | | mysql | | performance_schema | | sys | | test | +--------------------+ 6 rows in set (0.000 sec) MariaDB [(none)]\u0026gt; grant all privileges on gogs.* to \u0026#39;gogs\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;passwd\u0026#39; with grant option; Query OK, 0 rows affected (0.001 sec) build gogs:\npacman -S go node npm git clone --depth 1 https://github.com/gogs/gogs.git gogs cd gogs go build -o gogs ./gogs web "},{"id":2,"href":"/applications/blog/","title":"3A6000上搭建hexo博客","section":"Applications","content":"pacman -S nodejs npm git npm config set proxy=\u0026#34;http://127.0.0.1:7890\u0026#34; npm install -g hexo-cli mkdir loongsonwiki cd loongsonwiki hexo init git clone https://github.com/hdxw/hexo-theme-prowiki.git themes/hexo-theme-prowiki git submodule add https://github.com/hdxw/hexo-theme-prowiki.git themes/hexo-theme-prowiki vim _config.yml diff --git a/_config.yml b/_config.yml index 02b67a4..2391977 100644 --- a/_config.yml +++ b/_config.yml @@ -97,7 +97,7 @@ ignore: # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ -theme: landscape +theme: hexo-theme-prowiki # Deployment ## Docs: https://hexo.io/docs/one-command-deployment "},{"id":3,"href":"/firmware/grub/","title":"Grub编译与调试","section":"Firmware","content":" 1. Grub编译 # git clone https://github.com/loongarch64/grub.git cd grub ./bootstrap ./configure --with-platform=efi --target=loongarch64 --prefix=$(pwd) --disable-werror 2. Grub文件生成 # 2.1 grub.efi # ./grub-mkimage -p . -c /boot/mxd.cfg -d ./grub-core/ -O loongarch64-efi -o /boot/mxd.efi $(ls grub-core/ | grep -E \u0026#34;\\.mod$\u0026#34; | cut -d \u0026#34;.\u0026#34; -f 1 | uniq) 各参数可在help信息中查看.\n2.2 grub.cfg # ./grub-mkconfig -o /boot/mxd.cfg 除了生成grub.cfg外, 系统下还有一些用于参考的grub默认配置选项, 如: /etc/default/grub, /etc/grub.d等. 倘若修改这些文件, 还需要更新/boot/grub/grub.cfg, 有命令可以做到:\nupdate-grub 2.3 将grub安装至UEFI引导界面 # grub-install --boot-directory=/boot --efi-directory=/boot/efi --bootload-id=mxd /dev/sda --boot-directory指定在/boot作为根目录, 下寻找grub.cfg和模块.\n--efi-directory指定在/boot/efi下寻找grub的efi文件.\n--bootload-id指定生成的efi选项在UEFI下显示的名称.\n/dev/sda是安装grubloongarch64.efi的目标路径.\ngrub-install会调用grub-mkimage生成grub.efi文件, 同时会调用efibootmgr命令, 将grub.efi的路径通过UEFI运行时服务的接口写入到Flash中, 比如我这里举例是--bootload-id=mxd, 那在UEFI启动界面下将显示一个启动项, 名叫mxd, 指向/boot/efi/EFI/mxd/grubloongarch64.efi.\n3. GRUB界面 # 如图, GRUB界面下列出了几个选项, 其中第一项vm.mxd是我自己加的内核, 第二项Loongnix GNU/Linux是系统自带内核, 第三项Advanced options for Loongnix GNU/Linux是高级选项, 通常包含一些恢复模式的选项, 第四项是System Setup\u0026ndash;系统设置, 其实就是进入UEFI Setup界面.\n然后在界面的最下方:\nUse the ^ and v keys to select which entry is highlighted.\nPress enter to boot the selected OS, e to edit the commands before booting or c for a command-line.\n翻译一下:\n通过按上下键选择选项, 按执行进入选项, 按e去编辑选项, 按c进入GRUB的命令行.\n4. 编辑GRUB选项 # 通常我们通过UEFI执行GRUB的efi文件即可进入GRUB界面, 然后回车便可以启动内核, 但是倘若内核无法正常启动, 我们需要加串口调试, 就需要我们按e去编辑选项, 比如增加串口或者进入单用户模式等.\n按e后进入下图, 我们可以将光标通过上下左右按键, 移动至linux开头的那一行, 并在行末加入想要的参数比如串口console=ttyS0,115200 earlycon=uart,mmio,0x1fe001e0.\n可以看到, 界面最下面仍然有一些文字, 告诉我们按下Ctrl-X组合键或者F10可以直接启动, 按下Ctrl-c或F2进入到GRUB命令行, 按下ESC可以退回上一步.\n5. 手动找grub.cfg # 当我们在UEFI下执行GRUB的efi文件后, 加入grub.cfg的路径有问题, 则需要我们手动找到grub.cfg并且加载:\n逐个说明上述命令: 首先ls命令能够看到当前能够识别的设别, 其中hd0表示一块硬盘(Hard Disk0), 如果有多个硬盘将以hdx的形式显示.\n但是hd0并不具有文件系统, (hd0,msdos2)这种形式才表示有文件系统, msdos指MBR的分区格式, msdos2也就表示MBR硬盘上第二个分区.\n然后逐级用ls命令找到grub.cfg的路径:(hd0,msdos2)/boot/grub/grub.cfg.\n最后通过configfile命令, 解析grub.cfg文件, 即可重新回到GRUB的主界面.\n6. 没有grub.cfg的情况下引导内核 # 有时候, 我们会遇到有grub, 但是没有grub.cfg的情况, 这时, 我们可以稍微背下来两条命令, 这两条也就是grub.cfg中加载内核和加载initrd的命令: linux命令和initrd命令\nlinux命令后面加内核的路径, 以及内核启动参数\ninitrd命令后面加initrd的路径即可.\n然后执行boot即可启动. 如下图:\n7. Grub增加串口 # 7.1 使能串口 # grub\u0026gt; serial --unit=0 --speed=115200 或:\ngrub\u0026gt; serial --speed=115200 com0 --unit后指定com0到comN用作串口, 通常默认使用com0.\n但比如loongarch机器, 串口可能注册为了别的名字, 比如efi0, 所以真正执行的命令是:\ngrub\u0026gt; serial --speed=115200 efi0 7.2 使能串口输入 # 使能串口后, terminal_input和terminal_output命令分别查看可用的输入输出选项如下:\ngrub\u0026gt; terminal_input Active input terminals: console Available input terminals: serial_efi0 grub\u0026gt; grub\u0026gt; terminal_output Active output terminals: console gfxterm Available output terminals: serial_efi0 可见输入和输出选项中各自增加了一个可用选项:serial_efi0\n所以使用terminal_input和terminal_output命令分别设定可用的选项作为输入输出.\ngrub\u0026gt; terminal_input console serial_efi0 grub\u0026gt; terminal_output console gfxterm serial_efi0 串口下即可显示grub的一举一动了.\n8. Grub打开debug # grub\u0026gt; set pager=1 grub\u0026gt; set debug=all 打开后打印会从terminal_output中可用的选项中输出. 所以建议增加串口后使用, 否则屏幕不支持回翻也挺麻烦的.\n"},{"id":4,"href":"/system/Loongnix_FAQ/","title":"Loongnix_FAQ","section":"Systems","content":" 文章来源: http://docs.loongnix.cn/loongnix/faq/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A1%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html\n自2022/11/16日起桌面版软件源的key到期，如本地遇到key的问题，可依照下列方法对Key授权进行升级即可：\nwget http://pkg.loongnix.cn/loongnix/pool/main/d/debian-archive-keyring//debian-archive-keyring_2019.1.lnd.2_all.deb\ndpkg -i debian-archive-keyring_2019.1.lnd.2_all.deb\napt-key add /usr/share/keyrings/debian-archive-buster-loongarch64-stable.gpg\n1. loongnix桌面系统源 # http://pkg.loongnix.cn/loongnix/ 2. 开启sshd服务 # Loongnixi桌面系统默认关闭sshd服务，开启方法:\nloongson@loongson-pc:~$ sudo apt install openssh-server loongson@loongson-pc:~$ systemctl start ssh loongson@loongson-pc:~$ systemctl status ssh 3. 安装auditd软件包 # Loongnix系统默认不集成auditd软件包，若使用过程中用到审计功能，需手动安装auditd软件包:\nloongson@loongson-pc:~$ sudo apt install auditd \u0026amp;\u0026amp; systemctl start auditd \u0026amp;\u0026amp; systemctl status auditd 4. 制作rootfs文件系统 # 已安装debootstrap的前提下，使用以下方法制作rootfs文件系统：\ndebootstrap --no-check-gpg --variant=minbase --components=main,non-free,contrib --arch=loongarch64 --foreign DaoXiangHu-stable iso http://pkg.loongnix.cn/loongnix/ chroot iso debootstrap/debootstrap --second-stage cd iso chroot . 执行debootstrap操作时，如果遇到下述错误现象：\nroot@loongson-pc:/home# debootstrap --no-check-gpg --variant=minbase --components=main,non-free,contrib --arch=loongarch64 --foreign DaoXiangHu iso http://10.2.5.28/os/loongnix-desktop-la64-20/debian E: No such script: /usr/share/debootstrap/scripts/DaoXiangHu 解决方法是：\nln -s /usr/share/debootstrap/scripts/sid /usr/share/debootstrap/scripts/DaoXiangHu 5. 锁定屏幕界面无法点击功能按键 # 锁定屏幕界面无法点击\u0026quot;切换用户、解锁、留言等\u0026quot;功能按键,此时,可以按一下ESC键，留言、解锁、取消等按键即可点击。\n6. 密码复杂度要求 # 修改普通用户密码或者root密码时，若密码复杂度较低，会报告“无效的密码： 没有足够的字符分类”、“无效的密码： 太短了”等提示。 出于安全考虑，Loongnix系统中提高了密码设置规则的复杂度，用户在设置密码时需包含四类字符(数字，小写字母，大写字母，特殊符号)且密码长度不低于8位。\n7. home键不能调用开始菜单 # Loongnix系统使用mate桌面，如果要打开开始菜单可以使用Alt+F1的快捷键。\n8. 运行命令vulkaninfo会报错 # vulkan的使用需要显卡的支持，amd显卡vulkaninfo输出正常。\n9. 使用npm安装软件包 # 先配置软件源再安装all架构的npm软件包，版本是7.5.2+ds-2。 需配置的软件源是：\ndeb [arch=amd64] https://mirrors.ustc.edu.cn/debian/ bullseye main non-free contrib 10. 图形环境下修改系统语言 # 安装lightdm-gtk-greeter-settings软件包。\n11. unit-firewalldservice-could-not-be-found # 需安装firewalld软件包。\n12. 配置软件包仓库 # loongson@loongson-pc:~$ sudo vim /etc/apt/sources.list //参考已有的格式，增加deb * deb-src *，保存退出 loongson@loongson-pc:~$ sudo apt-get update 13. 查看系统版本信息 # 查看系统及版本信息：\ncat /etc/os-release 14. 查看系统已安装软件包 # 查看系统上所有已安装的软件包：\nloongson@loongson-pc:~$ dpkg -list 15. 查询软件包文件列表 # 查询某个软件包打包的所有文件：\nloongson@loongson-pc:~$ dpkg --listfiles 包名 16. 编译安装非loongnix程序 # /usr/local/目录不受Loongnix软件包管理系统的控制。 用户可以将程序的源代码放在/usr/local/src /中，将二进制文件放入/usr/local/bin/，将库放入 /usr/local/lib/，将配置文件放入 /usr/local/etc/。 如果您的程序或文件确实必须放置在其他目录中，仍可以将它们存储在中/usr/local/目录，但需创建符号链接。\n17. loongnix-20loongarch64镜像默认密码 # Loongnix-20.loongarch64镜像的默认密码是： Loongson20 18. 升级最新系统版本 # 举例：若操作系统是loongnix-20.loongarch64.rc1版本，系统需升级至龙芯外网源的最新系统版本。\n（1）操作方法\nloongson@loongson-pc:~$ sudo apt update loongson@loongson-pc:~$ sudo apt install linux-image-loongson-3 linux-headers-loongson-3 loongson@loongson-pc:~$ apt upgrade （2）重启后查询系统版本和内核版本\nloongson@loongson-pc:~$ uname -a 输出： Linux loongson-pc 4.19.0-13-loongson-3 #1 SMP Tue Aug 17 01:55:23 UTC 2021 loongarch64 loongarch64 loongarch64 GNU/Linux loongson@loongson-pc:~$ cat /etc/issue 输出：Loongnix GNU/Linux 20 RC3 \\n \\l 19. 切换xfce主题 # （1）安装xfce桌面\nloongson@loongson-pc:~$ sudo apt-get install xorg xfce4 （2）安装桌面主题和图标主题\nloongson@loongson-pc:~$ sudo apt-get install whitesur-gtk-theme tela-circle-icon-theme （3）切换xfce桌面\nloongson@loongson-pc:~$ sudo update-alternatives --config x-session-manager 输入3，启动xfce桌面。回显如下：\nloongson@loongson-pc:~$ sudo update-alternatives --config x-session-manager 有 3 个候选项可用于替换 x-session-manager (提供 /usr/bin/x-session-manager)。 选择 路径 优先级 状态 ------------------------------------------------------------ * 0 /usr/bin/mate-session 50 自动模式 1 /usr/bin/mate-session 50 手动模式 2 /usr/bin/startxfce4 50 手动模式 3 /usr/bin/xfce4-session 40 手动模式 要维持当前值[*]请按\u0026lt;回车键\u0026gt;，或者键入选择的编号：3 (4) 重启系统\n20. 使用init3或telinit-3黑屏 # 目前systemd 分配的虚拟终端为tty1～6为字符终端，tty7为gui终端。init 3后，显示仍在tty7终端，但图形界面已经关掉，因此出现黑屏现象，出现此现象为正常现象。 如果想使用init 3 后，出现字符界面，可以提供两种实现的方法：\n方法一：将gui终端显示在tty1 修改/etc/lightdm/lightdm.conf文件，minimum-vt =1 重启lightdm服务，systemctl restart lightdm 方法二：初始化tty7的字符终端 修改/etc/systemd/logind.conf文件，NAutoVTs=7 重启系统 21. u盘格式化为ext4后宿主为root而当前用户 # 解决方法：\nchown -R loongson:loongson u盘设备名 22. 命令行模式中文显示乱码 # 解决方法：\nloongson@loongson-pc:~$ dpkg -l |grep zhcon //判断是否安装zhcon软件包 loongson@loongson-pc:~$ sudo apt install zhcon loongson@loongson-pc:~$ zhcon --utf8 //字符界面执行 23. 软件光标切换成硬件光标 # 目前loongnix系统中默认使能的是软件光标。 将软件光标切换成硬件光标的方法：\nloongson@loongson-pc:~$ sudo vim /usr/share/X11/xorg.conf.d/20-loongson.conf Option \u0026#34;SWcursor\u0026#34; \u0026#34;true\u0026#34; 修改为 Option \u0026#34;SWcursor\u0026#34; \u0026#34;false\u0026#34; 24. 桌面系统手动分区注意事项 # 分区 介绍 分区挂载点 分区文件系统格式 推荐大小（仅供参考，可自行修改） 备注 efi分区 efi系统分区是一个FAT16或FAT32格式的物理分区，支持EFI模式的电脑需要从 ESP 启动系统，ESP是系统引导分区。 /boot/efi fat32 300MB pmon固件可不分，uefi固件必须分，同时需要勾选esp标识 boot分区 boot分区是操作系统的内核及在引导过程中使用的文件存放的分区。 /boot ext2/3/4 300MB 可以不分，如想在PMON固件下分boot分区时，必须将boot分区分为ext2/3/4或fat32/16格式的文件系统 根分区 根分区就是root分区，用于存放系统数据的分区 / 均支持,推荐xfs \u0026gt;= 20G 必须要分，最小10G data分区 data分区用于存放用户数据、应用数据的分区 /data 均支持,推荐xfs 除去其余分区之外的所有磁盘大小 可以不分，但会影响后续使用新版系统升级功能时，数据丢失的情况。最小分5G可以安装系统，但是后续新建用户和安装应用软件可能会出现磁盘不足的情况。 restore分区 restore分区用于系统备份功能使用的分区，该分区为隐藏状态 /restore 均支持推荐xfs \u0026gt;= 20G 可以不分，但会影响后续使用新版系统升级功能时，数据丢失的情况。最小分区大小和根分区一致 swap分区 swap分区，即交换区，系统在物理内存（运行内存）不够时，与Swap分区进行交换 无挂载点 linuxswap \u0026gt;=8G 可以不分，但是当内存不够用时，系统可能会卡死;最小分2G 25. igbuioko模块的编译方法 # igb_uio.ko模块是独立于dpdk提供的。 编译igb_uio.ko模块对应的代码获取位置是： http://git.dpdk.org/dpdk-kmods/ 编译方法：\nloongson@loongson-pc:~$git clone http://dpdk.org/git/dpdk-kmods loongson@loongson-pc:~$cd dpdk-kmods loongson@loongson-pc:~$make loongson@loongson-pc:~/dpdk-kmods/linux/igb_uio$ ls igb_uio.ko igb_uio.ko 如果在编译igb_uio.ko时报错，需要内核中默认支持CONFIG_UIO=m\n26. 查看内存页大小 # loongson@loongson-pc:~$ getconf PAGESIZE 16384 loongson@loongson-pc:~$ arch loongarch64 27. 默认软件源仓库 # （1）Loongnix-20版本mate主题默认集成的软件源\nroot@loongson-pc:/home/loongson# cat /etc/apt/sources.list deb http://pkg.loongnix.cn/loongnix DaoXiangHu-stable main contrib non-free （2）Loongnix-20版本cartoons主题默认集成的软件源\nroot@loongson-pc:/home/loongson# cat /etc/apt/sources.list deb http://pkg.loongnix.cn/loongnix DaoXiangHu-stable main contrib non-free deb http://pkg.loongnix.cn/loongnix DaoXiangHu-cartoons main contrib non-free 28. 查看内核和编译器版本 # （1）内核版本\nloongson@loongson-pc:~$ dpkg -l |grep linux-libc-dev ii linux-libc-dev 4.19.190-rc6.lnd.1 loongarch64 Linux support headers for userspace development loongson@loongson-pc:~$ uname -a Linux loongson-pc 4.19.0-17-loongson-3 #1 SMP 4.19.190-6 Thu Mar 31 01:15:47 UTC 2022 loongarch64 loongarch64 loongarch64 GNU/Linux （2）gcc编译器版本\nloongson@loongson-pc:~$ gcc --version gcc (Loongnix 8.3.0-6.lnd.vec.30) 8.3.0 Copyright (C) 2018 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 29. 取消密码复杂度设置 # 安装Loongnix系统时对设置的密码无复杂度要求。 修改密码时，密码复杂度遵循的规则是:密码长度最短为8，大写、小写、数字、字符这4类中，应至少满足3类。 在Loongnix-20.2.loongarch64系统中，修改密码时取消密码复杂度规则。 以用户名为“loongson”举例：\nloongson@loongson-pc:~$ cat /etc/issue Loongnix GNU/Linux 20 Release 2 \\n \\l loongson@loongson-pc:~$ sudo su [sudo] loongson 的密码： root@loongson-pc:/home/loongson# passwd loongson //设置新的密码为loongson，不再有复杂度要求 新的 密码： 重新输入新的 密码： passwd：已成功更新密码 30. 在mate-terminal终端配置软件包源代码的源地址 # 软件包源代码的源地址配置方法,以Loongnix-20.2.loongarch64版本mate主题的系统为例：\nloongson@loongson-pc:~$ sudo echo \u0026#34;deb-src http://pkg.loongnix.cn/loongnix DaoXiangHu-stable main contrib non-free\u0026#34; \u0026gt;\u0026gt;/etc/apt/sources.list loongson@loongson-pc:~$ sudo apt update 31. loongnix桌面系统获取源代码 # Loongnix桌面系统如何获取源代码? 以mate-panel为例：\n（1）mate-terminal终端获取mate-panel源代码\nroot@loongson-pc:/home/loongson# cat /etc/apt/sources.list deb http://pkg.loongnix.cn/loongnix DaoXiangHu-stable main contrib non-free deb-src http://pkg.loongnix.cn/loongnix DaoXiangHu-stable main contrib non-free root@loongson-pc:/home/loongson# apt source mate-panel Reading package lists... Done NOTICE: \u0026#39;mate-panel\u0026#39; packaging is maintained in the \u0026#39;Git\u0026#39; version control system at: https://salsa.debian.org/debian-mate-team/mate-panel.git ......省略...... dpkg-source: info: extracting mate-panel in mate-panel-1.20.5 dpkg-source: info: unpacking mate-panel_1.20.5.orig.tar.xz dpkg-source: info: unpacking mate-panel_1.20.5-1.1.lnd.4.debian.tar.xz dpkg-source: info: using patch list from debian/patches/series dpkg-source: info: applying 0001_RDA-support-Make-MATE-panel-aware-of-being-run-insid.patch dpkg-source: info: applying 0002_mate-panel-panel-menu-items.c-Only-offer-Shutdown-bu.patch dpkg-source: info: applying 0003_configure.ac-Report-RDA-support-status-in-configurat.patch dpkg-source: info: applying 0004_configure.ac-Explicitly-require-in-RDA-0.0.3.patch dpkg-source: info: applying 0005_change_default_layout.patch dpkg-source: info: applying 0006_add_loongnix_layout.patch dpkg-source: info: applying 0007_add_switch_loongnix_layout.patch dpkg-source: info: applying 0008_add_def_weather_temperature.patch dpkg-source: info: applying 0009_add_restrictions_to_loongnix_layout.patch （2）网页获取mate-panel源代码\nhttp://pkg.loongnix.cn/loongnix/pool/main/m/mate-panel/ 32. loongnix-201livecdcartoon系统升级后桌面无图标显示 # 解决办法:\nloongson@loongson-pc:~$ sudo apt update loongson@loongson-pc:~$ sudo apt upgrade loongson@loongson-pc:~$ sudo apt install cartoon-desktop-environment 33. kpatch-升级到097后生成的模块文件运行时报错 # 解决办法： 升级内核到4.19.190-7以上版本\n©龙芯开源社区 all right reserved，powered by Gitbook文档更新时间： 2023-12-21 12:36:52\n"},{"id":5,"href":"/firmware/pmon/","title":"PMON的使用方法","section":"Firmware","content":" 更新: 新pmon固件已支持efi_stub, 详情查看 10.1节\n1. 查看设备 # PMON\u0026gt; devls syn0 wd0 usb0 sync0, igb0, em0 等字样,表示网络设备, 即网卡\nwd0, nvme0, usb0, cd0等字样表示存储设备, 即硬盘, U盘等.\n2. 查看pci信息 # PMON\u0026gt; pciscan \u0026gt;\u0026gt; BUS 0 \u0026lt;\u0026lt; Dev Fun Device description -------------------------- 0 0 vendor/product: 0x0014/0x7a00 (bridge, host, interface: 0x00, revision: 0x00) 0x00000000:0x00000000 mem @0x00000000, 0 bytes 0 1 vendor/product: 0x0014/0x7a10 (bridge, host, interface: 0x00, revision: 0x01) 0x00000000:0x00000000 mem @0x00000000, 0 bytes 0 2 vendor/product: 0x0014/0x7a20 (bridge, host, interface: 0x00, revision: 0x01) 0x00000000:0x00000000 mem @0x00000000, 0 bytes 0 3 vendor/product: 0x0014/0x7a30 (bridge, host, interface: 0x00, revision: 0x00) 0x00000000:0x00000000 mem @0x00000000, 0 bytes 4 0 vendor/product: 0x0014/0x7a24 (serialbus, USB, interface: 0x10, revision: 0x02) 64-bit mem,low address 0x59648004:0xffff8004 mem @0x59648000, 32768 bytes 0x00000000:0x00000000 mem @0x00000000, 0 bytes ...... ...... 3. 产看固件版本信息 # PMON\u0026gt; vers PMON: PMON 5.0.3-Release (loongson) #233: Wed Oct 18 15:09:40 CST 2023 commit d044be8f495e97082c8905b131d525ef31ade0b9 Author: Xiangdong Meng \u0026lt;mengxiangdong@loongson.cn\u0026gt; Date: Wed Sep 6 15:15:31 2023 +0800 4. 查看寄存器信息 # PMON\u0026gt; d8 0x800000001fe00020 2 800000001fe00020 : 0000303030364133 0000000000000000 3A6000.......... 5. 查看磁盘信息 # 这里fdisk命令后面的设备名是在第一节中devls命令列出来的.\nPMON支持GPT和MBR分区\nPMON暂不支持设备热插拔.\nMBR:\nPMON\u0026gt; fdisk usb0 Device Boot Start End Sectors Id System usb0a 2048 122880000 122877952 83 Linux GPT:\nPMON\u0026gt; fdisk usb0 Device Boot Start End Sectors Id System usb0a 2048 122877951 122875904 0FC63DAF Linux filesystem 6. 查看磁盘中的文件 # /dev/fs/后的字符是fdisk usb0命令中, Device一列中显示的内容.\nPMON只支持Fat, Ext2/3/4, ISO9660等分区\nPMON在查看文件时, 通常不用指定文件系统类型.\n比如加载一个fat分区的内容: load /dev/fs/usb0/和load /dev/fs/fat@usb0/的效果是一样的\nFat分区:\nPMON\u0026gt; load /dev/fs/usb0/ gz.mxd \u0026lt;FILE\u0026gt; 993222 boot.cfg \u0026lt;FILE\u0026gt; 403 vm.mxd \u0026lt;FILE\u0026gt; 95024056 /dev/fs/fat@usb0/: Is a directory ext2/ext3/ext4分区:\nPMON\u0026gt; load /dev/fs/usb1a/ |./ ../ lost+found/ gz.mxd boot.cfg /dev/fs/ext4@usb1a/: Undefined error: 0 7. 加载内核 # PMON\u0026gt; load /dev/fs/usb0a/vm.mxd \\Loading file: /dev/fs/fat@usb0a/vm.mxd (elf) (elf) 0x9000000000200000/20053784 + 0x151ff18/922672(z) + 31926 syms| Entry address is 00c01000 8. 加载initrd # PMON\u0026gt; initrd /dev/fs/usb0a/initrd.img-4.19.0-19-loongson-3 Loading initrd image /dev/fs/usb0a/initrd.img-4.19.0-19-loongson--dl_offset 9000000090000000 addr 9000000090000000 (bin) 9. 启动内核 # 必须要在加载内核之后执行:\nPMON\u0026gt; g console=ttyS0,115200 earlycon=uart,mmio,0x1fe001e0 root=/dev/sda3 Warning! NVRAM checksum fail. Reset! Reached finished_ap_limit=7 in a5 microseconds BootCore ID: 0 Collect AP: 7 Total Core: 8 ACPI: ACPI tables init. VBIOS crc check is wrong,use default setting! GMEM: Get vbios from ls3a spi done! Init acpi table OK! set coherent [ 0.000000] Linux version 4.19.190+ (mengxiangdong@5.5) (gcc version 8.3.0 (GCC)) #9 SMP Tue Oct 17 11:14:31 CST 2023 [ 0.000000] 64-bit Loongson Processor probed (LA664 Core) [ 0.000000] CPU0 revision is: 0014d000 (Loongson-64bit) [ 0.000000] FPU0 revision is: 00000001 [ 0.000000] efi: SMBIOS=0xfffe000 ACPI 2.0=0xfefe000 NEWMEM=0xb036800 [ 0.000000] earlycon: uart0 at MMIO 0x000000001fe001e0 (options \u0026#39;\u0026#39;) [ 0.000000] bootconsole [uart0] enabled [ 0.000000] ACPI: Early table checksum verification disabled [ 0.000000] ACPI: RSDP 0x000000000FEFE000 000024 (v02 LOONGS) ...... ...... 10. 加载引导文件 # UEFI通过找到grub.efi, 接着找到grub.cfg, 进而引导内核\n而PMON只需要找到boot.cfg文件即可. PMON默认会从/和/boot目录中找boot.cfg\n倘若没有找到, 可以手动加载:\nPMON\u0026gt; bl /dev/fs/fat@usb0a/boot.cfg ������������������������������������������������Ŀ � Boot Menu List � ������������������������������������������������Ĵ � -\u0026gt; 1 Loongnix 20 GNU/Linux 4.19.0-19-loongson-3� � � � � � � � � � � � � � � � � � Please Select Boot Menu [1] � �������������������������������������������������� Use the UP and DOWN keys to select the entry. Press ENTER to boot selected OS. Press \u0026#39;c\u0026#39; to command-line. Booting system in [2] second(s) 10.1. 加载grub # 最新pmon固件已经支持efi_stub, 支持像UEFI一样加载grub.efi.\nPMON\u0026gt; bootefi /dev/fs/fat@usb0a/EFI/BOOT/BOOTLOONARCH64.efi 11. 查看文件 # PMON\u0026gt; devcp /dev/fs/fat@usb0a/boot.cfg /dev/tty0 default 0 timeout 3 showmenu 0 title Loongnix 20 GNU/Linux 4.19.0-19-loongson-3 kernel /dev/fs/fat@usb0a/vmlinuz-4.19.0-19-loongson-3 initrd /dev/fs/fat@usb0a/initrd.img-4.19.0-19-loongson-3 args root=/dev/sda3 console=ttyS0,115200 loglevel=8 12. 配置网络 # PMON\u0026gt; devls Device name Type syn0 IFNET usb0 DISK PMON\u0026gt; ifconfig syn0 192.168.1.13 synopGMAC_linux_open called Version = 0xd137 MacAddr = 0x3e 0xd0 0x62 0xf5 0x46 0x94 ===phy HALFDUPLEX MODE DMA status reg = 0x0 before cleared! DMA status reg = 0x0 after cleared! register poll interrupt: gmac 0 ==arp_ifinit done ===phy FULLDUPLEX MODE Link is with 1000M Speed PMON\u0026gt; 13. 加载网络文件 # PMON支持从网络加载内核, 支持的协议有http和tftp\nhttp:\nPMON\u0026gt; load http://192.168.1.4/vm.mxd \\Loading file: http://192.168.1.4/vm.mxd (elf) (elf) 0x9000000000200000/20053784 + 0x151ff18/922672(z) + 31926 syms| Entry address is 00c01000 tftp:\nPMON\u0026gt; load tftp://192.168.1.4/vm.mxd \\Loading file: tftp://192.168.1.4/vm.mxd (elf) (elf) 0x9000000000200000/20053784 + 0x151ff18/922672(z) + 31926 syms| Entry address is 00c01000 14. 更新固件 # PMON更新固件的命令为fload\n与加载内核类似, 可以从硬盘加载, 也可以从网络加载\n从硬盘加载:\nPMON\u0026gt; fload /dev/fs/usb0a/gz.mxd Loading file: /dev/fs/fat@usb0a/gz.mxd dl_offset 900000000f800000 addr 900000000f800000 (bin) - Loaded 993222 bytes Programming flash 900000000f800000:f27c6 into 800000001c000000 Erase end! -Programming end! 从tftp服务器加载:\nPMON\u0026gt; fload tftp://192.168.1.4/gz.mxd Loading file: tftp://192.168.1.4/gz.mxd dl_offset 900000000f800000 addr 900000000f800000 (bin) - Loaded 993222 bytes Programming flash 900000000f800000:f27c6 into 800000001c000000 Erase end! -Programming end! 从http服务器加载:\nPMON\u0026gt; fload http://192.168.1.4/gz.mxd Loading file: http://192.168.1.4/gz.mxd dl_offset 900000000f800000 addr 900000000f800000 (bin) - Loaded 993222 bytes Programming flash 900000000f800000:f27c6 into 800000001c000000 Erase end! -Programming end! "},{"id":6,"href":"/applications/qemu/","title":"Qemu使用","section":"Applications","content":" 部分环境准备: # qemu: https://gitlab.com/qemu-project/qemu.git\n固件: https://github.com/loongson/Firmware/raw/main/LoongArchVirtMachine/edk2-loongarch64-code.fd\n系统: http://pkg.loongnix.cn/loongnix/isos/Loongnix-20.5/\nqemu安装 # # Arch系 pacman -S qemu-system-loongarch64 # Debian系 apt install qemu-system-loongarch64 # Fedora系 yum install qemu-system-loongarch64 自己编译安装:\ngit clone https://gitlab.com/qemu-project/qemu.git cd qemu mkdir build4la cd build4la ../configure --target-list=loongarch64-softmmu --enable-kvm --disable-werror --enable-vnc --enable-debug --enable-gdb make -j 8 qemu使用 # qemu启动固件: # ./qemu-system-loongarch64 -m 4G -smp 1 --cpu la464 --machine virt -bios edk2-loongarch64-code.fd -display none --serial stdio 参数说明:\n./qemu-system-loongarch64: 这是QEMU模拟器的可执行文件，用于模拟LoongArch64架构的系统。\n-m 4G: 指定为虚拟机分配4GB内存（4096MB）。\n-smp 1: 设置虚拟机的CPU核心数为1个。\n--cpu la464: 指定要使用的虚拟CPU类型为la464，这是Loongson公司基于LoongArch架构的CPU型号或特性标识。\n--machine virt: 指定虚拟机的机器类型为“virt”，这是一个通用的、基于QEMU内部模型的虚拟机平台。\n-bios edk2-loongarch64-code.fd: 使用名为edk2-loongarch64-code.fd的固件镜像作为UEFI BIOS。这通常是一个包含UEFI固件实现的文件，用于在虚拟机启动时加载和执行。\n-display none: 关闭图形显示输出，意味着虚拟机不会打开一个窗口来显示图形界面。\n--serial stdio: 将虚拟机的串行端口连接到主机的标准输入/输出。这样，虚拟机的控制台输出将通过主机的终端进行显示，可以与虚拟机进行交互。\n综上所述，该命令是在QEMU中启动一个具有1个CPU核心、4GB内存的LoongArch64架构虚拟机，并使用特定的UEFI固件镜像引导，同时将虚拟机的控制台输出重定向到主机终端。\nqemu通过固件启动系统 # ./qemu-system-loongarch64 -m 4G -smp 1 --cpu la464 --machine virt -bios ../../qemu-kernel-debug/edk2-loongarch64-code.fd -display none --serial stdio -device virtio-gpu-pci -device nec-usb-xhci,id=xhci,addr=0x1b -device usb-tablet,id=tablet,bus=xhci.0,port=1 -device usb-kbd,id=keyboard,bus=xhci.0,port=2 -net nic,model=virtio -net user,hostfwd=tcp::10021-:22 -hda ../../qemu-kernel-debug/Loongnix-20.5.mate.mini.loongarch64.cn.qcow2 --accel kvm 基于上节, 其余的参数说明:\n-device virtio-gpu-pci: 添加一个virtio GPU设备（PCI总线上的图形卡）以支持图形加速。\n-device nec-usb-xhci,id=xhci,addr=0x1b: 添加USB 3.0控制器（nec-usb-xhci），并赋予ID为xhci，地址为0x1b。\n-device usb-tablet,id=tablet,bus=xhci.0,port=1: 添加一个USB触摸板设备，并将其连接到之前定义的USB控制器上，端口号为1。\n-device usb-kbd,id=keyboard,bus=xhci.0,port=2: 添加一个USB键盘设备，并同样连接到前述USB控制器上，端口号为2。\n-net nic,model=virtio: 添加一个virtio类型的网络接口卡（NIC）。\n-net user,hostfwd=tcp::10021-:22: 启用用户模式网络堆栈，同时设置端口转发规则，将主机的10021端口转发到虚拟机的22端口（通常这是SSH服务端口）。\n-hda Loongnix-20.5.mate.mini.loongarch64.cn.qcow2: 指定虚拟机硬盘映像路径，这里是一个名为“Loongnix-20.5.mate.mini.loongarch64.cn”的qcow2格式磁盘镜像。\n--accel kvm: 如果宿主机支持KVM硬件虚拟化技术，则启用加速功能以提高虚拟机性能。\n总结：这个命令是启动了一个带有特定硬件设备配置的LoongArch64虚拟机，包括内存、CPU、显卡、USB控制器、USB外设、网络适配器以及硬盘驱动，并使用KVM加速功能，还设置了端口转发规则以便从主机访问虚拟机中的服务。\nqemu文件系统挂载与卸载 # modprobe nbd max_part=16 qemu-nbd -c /dev/nbd0 ./Loongnix-20.5.mate.mini.loongarch64.cn.qcow2 fdisk -l /dev/nbd0 mount /dev/nbd0p2 /mnt/ umount /mnt 在mount之后可以进行文件操作.\n"},{"id":7,"href":"/firmware/uefi/","title":"从UEFI如何启动到系统","section":"Firmware","content":" UEFI须知 # 1. 进入UEFI setup界面 # 在串口或者显示界面下显示BDS字样的时候(如下图), 稍微按按上下键即可进入Setup界面 2. Setup界面 # 无论是Intel还是loongson, BIOS下都有设置的接口, PMON也有, 无非是显示样式差异, 原理相通. Loongson的UEFI界面如下图\n不同的条目, 用于设置不同的功能. 其中普通用户通常只需要进入BootManager界面选择相应的启动目标即可. 3. BootManager界面 # 在下图区域1中为条目名称, 区域2中为UEFI下解析的路径名(有点专业,不用理解), 总之, 左边看不懂时就看右边, 找相关的关键字, 比如下图, 左侧是设备名, 不太能看出是什么设备, 右侧则有Sata字样可以识别. 4. Shell下操作 # 通常, 正常情况下, 系统直接启动, 用户无法感知上述界面的存在, 但当出现一些问题时, 我们可能需要进入Shell下进行操作, 如上图中的第二个条目, 选中后回车进入下图界面: 4.1. 显示启动设备 # 正常情况下， 进入Shell后仍然会提示启动相关的设备, 如上图, 倘若由于操作过多, 或者显示bug等, 我们还想再次看到相关的显示, 则需要通过map命令再次显示，如下图：\n可以看到, 其实和默认进入Shell的打印是一样的, 不过为了防止打印被冲刷掉, 还是要会一下.\n4.2. 进入设备及查看文件 # 看上图, 图中黄色字体, FS0: , BLK0:等, 可以理解为不同设备的重命名, 其中FS开头的标识表示该设备的文件系统可以识别, BLK开头的表示表示该设备不存在文件系统, 或者文件系统不可识别. 总之对我们有意义的就只有FS开头的标识.\n只有含有文件系统的设备我们才能访问, 所以UEFI下需要访问的GRUB, 内核等EFI文件一定是放在UEFI下能够识别的文件系统中的. 也就是FS开头的设备.\n如何访问文件系统中的文件呢, 先看下图:\n进入设备时比较特殊, 输入FS0:即可,不能是cd FS0:, 也不能不加后面的冒号.\n进入设备之后就和linux的操作很类似了, 使用cd, ls即可.\n然后ls看到的緑色显示的文件, 也就是UEFI下的可执行文件\u0026ndash;EFI文件. 运行时也无需像linux那样在前面加路径才能执行, UEFI下直接输入文件名即可.\n哦, 值得一提, UEFI下可以通过Tab键实现文件名补全.\n4.3. UEFI下的其他操作 # 如第一节的内容, UEFI下的界面下通常会有很多选项, 其中用户比较关心的选项大概有:\n快速启动: 忽略部分设备初始化, 启动速度加快, 比如x86部分机器需要关闭此选项才能更改启动顺序, 选择系统安装盘. 安全启动: 开启安全校验, 部分外插设备未经过校验可能无法识别, 所以x86装机时可能也需要关闭此项, 防止U盘无法识别. 传统模式: 通常是用于兼容很久的系统启动. 比如龙芯的机器开启传统模式可以安装旧世界系统, 关闭则安装新世界系统, x86下可能叫CSM\u0026hellip;, 开启则可以引导MBR分区的硬盘, 关闭则引导GPT格式硬盘. 高级选项:一些高级的功能开关, 普通用户可能不需要使用, 比如上述传统模式, 龙芯的机器将其放在了高级选项中, 英文是LegacyMode, (看不懂这种英文的同学自我PUA一下). 其他如有需求请在工程师指导下使用. 4.4. UEFI下的一些Shell命令 # 比如pci命令, 具体可以通过pci -?查看具体使用方法, 这里不详细演示.\n常用的命令有:cd, ls, map, pci, mm, dmem, ifconfig, edit, vers等.\n5. UEFI下更新固件方法 # 还有spi命令不得不单独强调, 一个产品往往需要保持更新才能更好的满足用户的需求. 固件是尤其重要的一点.\n当我们需要更新固件(UEFI和PMON都是固件)时, 在Shell下找到文件后, 通过spi -u filename的命令, 即可完成固件更新.\n当然图形界面下也有相关接口, 可以自己理解一下英文再操作.\nGRUB # GRUB界面 # 如图, GRUB界面下列出了几个选项, 其中第一项vm.mxd是我自己加的内核, 第二项Loongnix GNU/Linux是系统自带内核, 第三项Advanced options for Loongnix GNU/Linux是高级选项, 通常包含一些恢复模式的选项, 第四项是System Setup\u0026ndash;系统设置, 其实就是进入UEFI Setup界面.\n然后在界面的最下方:\nUse the ^ and v keys to select which entry is highlighted.\nPress enter to boot the selected OS, e to edit the commands before booting or c for a command-line.\n翻译一下:\n通过按上下键选择选项, 按执行进入选项, 按e去编辑选项, 按c进入GRUB的命令行.\n1. 编辑GRUB选项 # 通常我们通过UEFI执行GRUB的efi文件即可进入GRUB界面, 然后回车便可以启动内核, 但是倘若内核无法正常启动, 我们需要加串口调试, 就需要我们按e去编辑选项, 比如增加串口或者进入单用户模式等.\n按e后进入下图, 我们可以将光标通过上下左右按键, 移动至linux开头的那一行, 并在行末加入想要的参数比如串口console=ttyS0,115200 earlycon=uart,mmio,0x1fe001e0.\n可以看到, 界面最下面仍然有一些文字, 告诉我们按下Ctrl-X组合键或者F10可以直接启动, 按下Ctrl-c或F2进入到GRUB命令行, 按下ESC可以退回上一步.\n2. 手动找grub.cfg # 当我们在UEFI下执行GRUB的efi文件后, 加入grub.cfg的路径有问题, 则需要我们手动找到grub.cfg并且加载:\n逐个说明上述命令: 首先ls命令能够看到当前能够识别的设别, 其中hd0表示一块硬盘(Hard Disk0), 如果有多个硬盘将以hdx的形式显示.\n但是hd0并不具有文件系统, (hd0,msdos2)这种形式才表示有文件系统, msdos指MBR的分区格式, msdos2也就表示MBR硬盘上第二个分区.\n然后逐级用ls命令找到grub.cfg的路径:(hd0,msdos2)/boot/grub/grub.cfg.\n最后通过configfile命令, 解析grub.cfg文件, 即可重新回到GRUB的主界面.\n3. 没有grub.cfg怎么办? # 有时候, 我们会遇到有grub, 但是没有grub.cfg的情况, 这时, 我们可以稍微背下来两条命令, 这两条也就是grub.cfg中加载内核和加载initrd的命令: linux命令和initrd命令\nlinux命令后面加内核的路径, 以及内核启动参数\ninitrd命令后面加initrd的路径即可.\n然后执行boot即可启动. 如下图:\n"},{"id":8,"href":"/system/build_openharmony_for_2k500/","title":"龙芯2K500先锋派OpenHarmony构建指北","section":"Systems","content":" 文章来源: https://bbs.loongarch.org/d/435-2k500openharmony\n一、系统需求和环境配置 # 官方推荐系统是ubuntu 20.4，预留60G到80G的磁盘空间，交换分区推荐8G以上，主要环境是python3.9。 也可以使用Debian构建，留意python版本，python3.10及更新版本要改一行代码，才能正常运行hb构建工具。\n需要安装的软件包：\nsudo apt update sudo apt upgrade sudo apt install apt-utils binutils bison flex bc build-essential make mtd-utils gcc-arm-linux-gnueabi u-boot-tools python3.9 python3-pip git zip unzip curl wget gcc g++ ruby dosfstools mtools default-jre default-jdk scons python3-distutils perl openssl libssl-dev cpio git-lfs m4 ccache zlib1g-dev tar rsync liblz4-tool genext2fs binutils-dev device-tree-compiler e2fsprogs git-core gnupg gnutls-bin gperf lib32ncurses5-dev libffi-dev zlib* libelf-dev libx11-dev libgl1-mesa-dev lib32z1-dev xsltproc x11proto-core-dev libc6-dev-i386 libxml2-dev lib32z-dev libdwarf-dev grsync xxd libglib2.0-dev libpixman-1-dev kmod jfsutils reiserfsprogs xfsprogs squashfs-tools pcmciautils quota ppp libtinfo-dev libtinfo5 libncurses5 libncurses5-dev libncursesw5 libstdc++6 gcc-arm-none-eabi vim ssh locales doxygen libxinerama-dev libxcursor-dev libxrandr-dev libxi-dev npm libfl-dev 二、注册gitee账号和代码下载前的准备 # 源码下载推荐使用gitee的repo工具，从OpenHarmony gitee仓库下载代码，也可以使用OpenHarmony全量代码包。 参见资源链接1。使用repo工具需要gitee账号，并上传ssh公钥到账号的\u0026quot;ssh配置”里面，并且需要对git进行全局配置。大致过程如下：\n1、使用电子邮箱注册gitee账号，如 abc@163.com 2、使用如下命令建立公钥 ssh-keygen -t ed25519 -C \u0026quot;Gitee SSH Key\u0026quot; 3、获取公钥内容并复制到gitee的ssh配置里面 cat ~/.ssh/id_ed25519.pub 4、获取gitee repo工具并赋予可执行权限 sudo curl -s https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 \u0026gt; /usr/local/bin/repo sudo chmod a+x /usr/local/bin/repo pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests 5、对git进行全局配置，配置账号和选项并进行测试 // 配置git，以abc@163.com为例，实际配置以注册账号为准 git config --global user.name \u0026quot;abc\u0026quot; git config --global user.email \u0026quot;abc@163.com\u0026quot; git config --global credential.helper store // 测试 ssh -T git@gitee.com\n三、开放鸿蒙代码下载和环境配置 # // 建立 OpenHarmony 目录 mkdir oh41 cd oh41 // 初始化 repo init -u git@gitee.com:openharmony/manifest.git -b refs/tags/OpenHarmony-v4.1-Release --no-repo-verify // 获取源码 repo sync -c -j4 // 获取大文件 repo forall -c \u0026#39;git lfs pull\u0026#39; // 获取预编译工具链 ./build/prebuilts_download.sh // 安装hb pip3 install build/hb // 环境测试，如下命令会输出hb的命令行帮助信息 hb help 四、应用龙芯2K500先锋派相关补丁和工具链 # 1、系统适配龙芯部分\n// 这部分是2K500先锋派适配代码，处于开发状态，建议进行动态跟踪并变通使用 // dayu400是hihope适配2K500先锋派的内部代号，需要在vendor和device中都有相关的配置 // vendor/hihope/dayu400 对应 hb set 里面的产品列表，定义的内容主要是“架构”和“功能”的定义 // device/board/hihope/dayu400 目录下包括适配OpenHarmony的各种补丁、构建参数的相关定义 // device/board/soc/loongson 目录下是LoongArch架构相关代码和定义 cd vendor rm -rf hihope # 删除 OpenHarmony-v4.1-Release 基础代码中的 vendor/hihope 仓库 git clone https://gitee.com/openharmony-sig/vendor_hihope.git hihope // 变通部分 cd hihope git checkout 切换至 OpenHarmony-4.1-Release 分支 cd device/board rm -rf hihope # 删除 OpenHarmony-v4.1-Release 基础代码中的 device/board/hihope 仓库 git clone https://gitee.com/openharmony-sig/device_board_hihope hihope // 变通部分 cd hihope 复制dayu210目录到临时目录 git checkout 切换至 OpenHarmony-4.1-Release 分支 粘贴dayu210目录到 hihope 目录下 cd device/soc # OpenHarmony-v4.1-Release 基础代码中没有 loongson 仓库 git clone https://gitee.com/ohos4la-l1/device_soc_loongson loongson 2、内核部分 获取 5.10.97 版本的Linux内核代码（v4.1-Release的内核为 5.10.184版本，当前的内核补丁尚无法完美打入，暂先使用3.2-Release的5.10.97 版本的内核）\n// 回到 openharmony 代码根目录 cd kernel/linux/ cp -r linux-5.10 linux-5.10.97 cd linux-5.10.97 git fetch origin OpenHarmony-3.2-Release:OpenHarmony-3.2-Release git switch OpenHarmony-3.2-Release 3、导入补丁集\n// 回到openharmony 代码根目录 // 变通部分 // 拷贝device/board/hihope/dayu400/patches 到 device/soc/loongson/ 目录 // 修改 device/board/hihope/dayu400/patch.sh cd device/board/hihope/dayu400 ./patch.sh 4、工具链安装和配置\n// 回到openharmony 代码根目录 // 下载 git clone https://gitee.com/loongarch_community/loongarch64-linux-gnu.git toolchain // 建立目录 mkdir -p prebuilts/gcc/linux-x86/loongarch/ // 解压 tar -C prebuilts/gcc/linux-x86/loongarch/ -xvf toolchain/toolchain-loongarch64-linux-gnu-gcc8-host-x86_64-2022-07-18.tar.xz // 重命名，符合dayu400交叉编译工具链配置 mv prebuilts/gcc/linux-x86/loongarch/toolchain-loongarch64-linux-gnu-gcc8-host-x86_64-2022-07-18 prebuilts/gcc/linux-x86/loongarch/loongarch64-linux-gnu/ // 标准库的临时变通使用 cp prebuilts/gcc/linux-x86/loongarch/loongarch64-linux-gnu/sysroot/usr/lib64/libstdc++.so prebuilts/gcc/linux-x86/loongarch/loongarch64-linux-gnu/sysroot/usr/lib64/libc++.so 五、构建环境配置和编译 # // 回到 openharmony 目录 hb set 选择 small -\u0026gt; hihope -\u0026gt; dayu400 // 如果没有报错信息，表示前述配置基本正确 hb build // 所有构建都存放在 out 目录下 // 若遇到报错，可删除out目录，重新运行 set \u0026amp; build 六、相关资源链接 # https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v4.1-release.md https://gitee.com/openharmony-sig/device_board_hihope/tree/OpenHarmony-4.1-Release/dayu400 https://gitee.com/openharmony-sig/device_board_hihope/blob/OpenHarmony-4.1-Release/dayu400/LS2K0500-DevGuide.md http://docs.openharmony.cn/pages/v4.1/zh-cn/device-dev/subsystems/subsys-build-all.md 七、补充资源 # 构建内核所需的支持LoongArch架构的mkimage，是个u-boot工具程序\nmkimage.zip\n"},{"id":9,"href":"/applications/ejtag/","title":"龙芯lajtag常用技巧","section":"Applications","content":"使用串口时:\ncd /tmp/ejtag-debug/ ./la_ejtag_debug_gpio -t source configs/configs.ls3a5000 在本机上运行时:\ncd /path/ejtag-debug/ ./la_ejtag_debug_usb -t source configs/configs.ls3a5000 cpus 查看pc\nset 查看通用寄存器及部分csr寄存器, 此时pc停在set时运行的地址.\ncont 从set处继续运行\nhb addr; cont 断点到addr处, 等待触发断点.\nhbls 查看断点\nwatch data; cont 检测通用寄存器, 当通用寄存器中和data一致时, 断点此处.\nwatchls 查看数据检测点.\nwatch data mask; cont 检测通用寄存器, 当通用寄存器中和data一致时, 断点此处. mask可以设置掩码.\nd1/d4/d8 addr length 按照1字节, 4字节, 8字节, 依次dump length个addr寄存器中的值.\nm1/m4/m8 addr data1 data2\u0026hellip; 按照1字节, 4字节, 8字节, 依次将dataX 写入addr地址.\ndisas addr length 反汇编addr处开始length长的内容.\ncsrs d8 num length 从第num个csr寄存器连续读出length个值.\ncsrs m8 num data 向第num个csr寄存器写入data.\ngdbserver 远程调试\nspi_program_flash file 烧录flash, 注意需要配合./la_ejtag_debug_usb程序使用. 以下内容来源于： https://zhuanlan.zhihu.com/p/368080970\n引言 # Ejtag分两个版本，Window版本、Linux版本。此处主要以Linux版本为例进行介绍。\nEjtag下载 # 下载地址： http://ftp.loongnix.org/embedd/ls1b/ejtag/ Linux版本分为龙芯版和X86版本，找到自己使用的版本压缩包如下：\n点击下载到本地。\nEjtag运行 # 1、下载Ejtag压缩包，解压到指定目录\n# tar xf ejtag-debug-mips64-v3.25.19.tar.gz ./ 2、使用linux主机root用户权限(必须root或者普通用户sudo)\n# cd ejtag-debug/ # ./ejtag_debug_usb 3、检查连接状态及驱动是否正常的方法如下 a) 将Ejtag的USB口插入主机，出现红蓝灯同时亮，一秒钟之后绿灯熄灭说明硬件连接正常。 b) 输入如下命令测试Ejtag硬件状态是否正常，如jtagled 0绿灯闪烁则正常，jtagled 1绿灯长亮则正常。如下：\ncpu0 -jtagled 0 #绿灯进行闪烁 cpu0 -jtagled 1 #绿灯长亮 c) 输入usblooptest测试Ejtag硬件能及连接状态是否正常，返回“jtag loop test ok”则正常。如下：\ncpu0 -usblooptest jtag loop test ok #连接状态正常 d) 输入usbver命令返回日期，则说明Ejtag硬件及连接状态正常。如下：\ncpu0 -usbver 0x20150105 #连接状态正常 4、Ejtag端连接板卡 a) 将USB端拔下， b) 板卡为断电模式； c) 将Ejtag接口端的三角号对准板卡上的1脚进行插入。(注意：此步骤一定要插正确，此步插错执行下面的步骤有可能烧坏CPU或者Ejtag调试器) d) 检查连接无误，将USB端口插入主机，板卡上电。连接如下图：\n5、进入Ejtag加载指定的平台配置文件，根据要调试板卡的平台选择不同的配置文件\n#在3A4000平台上使用的配置文件 cpu0 -source configs/config.ls3a4000 #在3A3000平台上使用的配置文件 cpu0 -source configs/config.ls3a3000 #在3A2000平台上使用的配置文件 cpu0 -source configs/config.ls3a2000 Ejtag使用 # 1、加载配置文件之后可以，采用如下方法确保板卡与主机之间连接正常。 a) 采用cpus命令读取CPU各个核的PC值。正常如下：\ncpu0 -cpus #说明主机通过Ejtag能够抓到目前板卡上CPU的运行到的地址。 #cpus [00] 0xffffffff9fc06030 [00] 0xffffffffbfc06600 [00] 0xffffffffbfc06600 [00] 0xffffffffbfc06600 异常如下：\ncpu0 -cpus #cpus [00] 0x00000000 [00] 0x00000000 [00] 0x00000000 [00] 0x00000000 #说明无法访问到板卡上CPU的运行状态。 出现异常，请检查前面步骤是否正确或者确认板卡上电启动是否正常。 b)采用set命令读取核上的通用寄存器。正常如下：\ncpu0 -set #set zero:0x0 at:0x10c80 v0:0xffffffffbfe001e0 v1:0xffffffffbfe001e0 a0:0x0 a1:0x40 a2:0xffffffffbfc022b8 a3:0xffffffffffffffff t0:0x900010001fe001c0 t1:0x84000000c84 t2:0xffffffffbbd0020c t3:0x400000 t4:0x0 t5:0x0 t6:0x2c24848100888010 t7:0x81000200008c8c40 s0:0x30300000 s1:0x0 s2:0x48a0a03812a04408 s3:0x800010a03c80000c s4:0xffffffffbfe00000 s5:0x2200804020400908 s6:0x303400905c601904 s7:0x4830092800248640 t8:0x8060840014aa2620 t9:0xa08828186e9706 k0:0x1c42408808405808 k1:0x4288ca184404101 gp:0xffffffff8f998000 sp:0xffffffff8f8fc000 s8:0x372002504000604 ra:0xffffffffbfc022b8 status:0x4000e0 lo:0x0 hi:0x0 badvaddr:0x1634e0124cd64658 cause:0x40008000 pc:0xffffffffbfc022e8 epc:0x8884c964c0020b4c 能够看到通用寄存器目前的状态。 异常如下：\ncpu0 -set #set 会出现set命令卡住的现象，请检查前面步骤是否正确或者确认板卡上电启动是否正常。 通常使用这两种方法来判断调试过程中的板卡是否能正常上电运行。 2、常用命令 ①　h 查看帮助 格式：\nh [cmd] ②　cpus 读取当前CPU各个核运行的地址。通常结合代码反汇编来寻找CPU卡在哪个地方，方便进一步定位问题。 格式：\ncpus [count[,cpubitmap]] ③　set 读写CPU的通用寄存器。通过用来判断CPU核是否处于运行状态；从sp/ra/status/cause/pc/epc等寄存器信息来定位板卡异常。 格式：\nset [regname|regno] [value] 例子：\ncpu0 -set #读出所有通用寄存器 cpu0 -set pc #读pc寄存器 cpu0 -set at #读at寄存器 #设置pc的数值是0xffffffffbfc00000 cpu0 -set pc 0xffffffffbfc00000 ④　cont 是continue的意思，退出Ejtag状态继续运行。一般常用于set命令停住CPU之后让CPU继续运行。 格式：\ncont ⑤　d1/d4/d8 是dump的意思，读取CPU、设备相关寄存器或者内存地址。 格式：\nd1 [addr] [count] :dump memory (byte) d4 [addr] [count] :dump memory (word) d8 [addr] [count] :dump memory (double word) 例子：\ncpu0 -d1 0xffffffffbfe00180 0x1 #d1 0xffffffffbfe00180 0x1 ffffffffbfe00180: 80 . cpu0 -d4 0xffffffffbfe00180 0x1 #d4 0xffffffffbfe00180 0x1 ffffffffbfe00180: ff003180 .1.. cpu0 -d8 0xffffffffbfe00180 0x1 #d8 0xffffffffbfe00180 0x1 ffffffffbfe00180: 3700ff00ff003180 .1.....7 ⑥　m1/m4/m8是modify的意思，改变写入寄存器或者内存地址新的数据。 格式：\nm1 [addr] [value] :modify memory (byte) m4 [addr] [value] :modify memory (word) m8 [addr] [value] :modify memory (double word) 例子：\ncpu1 -m1 0xffffffffbfe001e0 0x18 #m1 0xffffffffbfe001e0 0x18 cpu1 -d1 0xffffffffbfe001e0 0x1 #d1 0xffffffffbfe001e0 0x1 ffffffffbfe001e0: 18 m4/m8操作类似。 ⑦　setconfig 设置CPU调试相关的一些配置等。 格式：\nsetconfig [configname] [val] :setconfig for command 常用参数：\ncore.cpucount #设置cpu数目 core.cpuno #设置当前调试的cpu号 core.cpuwidth #设置cpu的数据宽度 例子：\ncpu0 -setconfig core.cpuno 3 #切换到CPU3上进行调试 #setconfig core.cpuno 3 cpu3- #该设置的快捷指令 cpu3 -cpu 2 #cpu 2 #setconfig core.cpuno 2 cpu2 - ⑧　disas 反汇编addr开始的count条指令。 格式：\ndisas [addr] [count] :disas memory 例子：\ncpu3 -disas 0xffffffffbfe00180 0x4 #disas 0xffffffffbfe00180 0x10 0xffffffffbfe00180: ff003180 sd zero,12672(t8) 0xffffffffbfe00184: 3700ff00 ori zero,t8,0xff00 0xffffffffbfe00188: 00000780 sll zero,zero,0x1e 0xffffffffbfe0018c: 00000101 0x101 ⑨　put/fput/sput 上传文件到板卡。 格式：\nput filename address [len] [offset], env: put_speed 例子：\ncpu0 -put gzrom.bin 0xffffffff84000000 #put gzrom.bin 0xffffffff84000000 pack: 0,time : 2, download_size : 0xac010, download rate=352264 B/S cpu0 - 该命令常用于定位PMON启动过程中拷贝gzrom.bin二进制到内存出现异常时，是由于内存不稳定导致还是flash有问题导致。同时也用于定位内核加载过程中卡死，来确定存储介质接口问题还是内存问题的的判断。 get/fget/sget 从addr开始的内存地址下载size大小内容存在file中。 格式：\nget filename address size 例子：\ncpu0 -get gzrom.bin.new 0xffffffff84000000 0xac010 #get gzrom.bin.new 0xffffffff84000000 0xac010 time : 7, size : 0xac010, upload rate=100646 B/S cpu0 - 该命令常用于定位系统卡死时，导出log_buf中未存入到硬盘上的dmesg内核日志，便于排查系统卡死之前有没有异常现象记录在内核日志中。 3、Ejtag的应用实例 a) 烧写PMON固件\ncpu0 -source configs/config.ls3a2000 cpu0 -call program_cachelock #烧写3A1000/3A2000 LPC接口的flash 或者： cpu0 -source configs/config.ls3a4000 cpu0 -call program_cachelock_spi #烧写3A3000/3A4000 SPI接口的flash 烧写过程中可能会出现，烧写不成功卡住的情况。通过如下方法进行尝试： ①　在“cpu0 -call program_cachelock”之前关闭看门狗cpu0 -wdt_close，然后进行烧写操作。 ②　在“cpu0 -call program_cachelock”之前先使用set命令停住CPU然后进行烧写操作。 ③　多次尝试均无效果可以更新以下Ejtag的驱动版本试一试。 b)连接gdb定位系统卡死的问题 如果CPU某个核出现卡死的现象 这种情况时无法运行gdbserver的，因此需要屏蔽掉卡死的核。就可以进入gdbserver了。 命令如下：\ncpu1 -setconfig core.cpuno 0 #切换到核0 cpu0 -setconfig gdbserver.cpubitmap 0xd #屏蔽掉核1 cpu0 -gdb #启动gdb 使用Ejtag中的gdbserver与开发机gdb连接方法：\ncpu0 -gdbserver #port 50010 开发机端： 进入gdb\n#gdb 链接gdbserver\ngdb) target remote :50010 Remote debugging using :50010 接下来就可以使用gdbserver进行问题定位了。\n想了解更多相关知识请关注公众号。\n"},{"id":10,"href":"/applications/clash/","title":"龙芯平台使用clash","section":"Applications","content":" 旧世界(Loongnix) # 来源: https://bbs.loongarch.org/d/177-loongnixclash\n下载后:\nunzip -x clash1130-loong64.zip ./clash -d dir_include_config.yaml 其中dir_include_config.yaml是config.yaml所在的文件夹路径.\n然后在设置中, 在首选项中设置代理服务器, 或者配置环境变量:\nhttp: port: 127.0.0.1 7890 https: port: 127.0.0.1 7890 socks: port: 127.0.0.1 7891 具体端口号信息在config.yaml中查看.\n新世界 # Archlinux # pacman -S clash clash -d dir_include_config.yaml 其中dir_include_config.yaml是config.yaml所在的文件夹路径.\n然后在设置中, 在首选项中设置代理服务器, 或者配置环境变量:\nhttp: port: 127.0.0.1 7890 https: port: 127.0.0.1 7890 socks: port: 127.0.0.1 7891 具体端口号信息在config.yaml中查看.\n"},{"id":11,"href":"/system/kernel/","title":"内核编译","section":"Systems","content":" 龙芯内核编译 # 目前龙芯已经由MIPS架构转战LoongArch架构.\nvmlinux+vmlinuz libmodules RamDisk_initrd 准备阶段 # 下面以LoongArch架构的编译为例. 编译器采用Gcc交叉编译LoongArch版本\n编译器版本 : loongarch64-linux-gnu-gcc-8.3.0 配置文件 采用龙芯默认配置: cp arch/loongarch/configs/loongson3_defconfig .config 开始编译 # vmlinux/vmlinuz\n执行 make ARCH=loongarch CROSS_COMPILE=/opt/LoongArch_Toolchains/loongarch64-linux-gnu-2020-11-06/bin/loongarch64-linux-gnu-(此为编译器路径 which gcc) menuconfig 进入图形化配置界面,开关相关功能,我们直接Esc退出.\n执行 make ARCH=loongarch CROSS_COMPILE=/opt/LoongArch_Toolchains/loongarch64-linux-gnu-2020-11-06/bin/loongarch64-linux-gnu- -j 16 //采用16线程进行编译(目前我是在服务器上编译,核数较多). 到此vmlinux/vmlinuz 非压缩和压缩版内核就编译完成. System.map 是符号表\n执行 make modules_install INSTALL_MOD_PATH=./ ARCH=loongarch CROSS_COMPILE=/opt/LoongArch_Toolchains/loongarch64-linux-gnu-2020-11-06/bin/loongarch64-linux-gnu- 编译lib/modules/ 驱动模块包,熟悉内核的人都了解,当配置menuconfig的时候,会将M的驱动以modules的形式在内核中加载. 将编译的文件进行使用 # 1.vmlinuz 放在os的/boot/下,并可以修改成自己喜欢的名字 vmlinuz_go\n2.将lib/modules/下的文件copy到os根目录/lib/modules/\n3.参考Deebian制作Ramdisk为例: 执行 使用draut进行制作,该脚本制作的Ramdisk支持了好几种文件系统,你可以简单制作RamDisk,这里就不详细介绍该命令了.将制作的*.img文件拷贝到/boot下.\ndracut 是一个事件驱动的 initramfs 基础设施。dracut(工具)被用来通过拷贝工具和文件，从一个已经安装的系统创建一个 initramfs 镜像，并将镜像与dracut框架结合在一起。\n4.修改grub引导程序,进行加载相应的内核和RamDisk.\n目前 grub在Deebian系统的目录: /boot/efi/boot/grub.cfg 修改linux命令加载的文件名-\u0026gt; vmlinuz_go initrd命令加载的文件名-\u0026gt; initrd.live "},{"id":12,"href":"/firmware/firmware/","title":"如何更新固件","section":"Firmware","content":" 在PMON下更新固件 # 详情 PMON使用方法\n从硬盘加载:\nPMON\u0026gt; fload /dev/fs/usb0a/gz.mxd Loading file: /dev/fs/fat@usb0a/gz.mxd dl_offset 900000000f800000 addr 900000000f800000 (bin) - Loaded 993222 bytes Programming flash 900000000f800000:f27c6 into 800000001c000000 Erase end! -Programming end! 从tftp服务器加载:\nPMON\u0026gt; fload tftp://192.168.1.4/gz.mxd Loading file: tftp://192.168.1.4/gz.mxd dl_offset 900000000f800000 addr 900000000f800000 (bin) - Loaded 993222 bytes Programming flash 900000000f800000:f27c6 into 800000001c000000 Erase end! -Programming end! 从http服务器加载:\nPMON\u0026gt; fload http://192.168.1.4/gz.mxd Loading file: http://192.168.1.4/gz.mxd dl_offset 900000000f800000 addr 900000000f800000 (bin) - Loaded 993222 bytes Programming flash 900000000f800000:f27c6 into 800000001c000000 Erase end! -Programming end! 在UEFI下更新固件 # 详情 uefi使用方法\nUEFI Interactive Shell v2.2 EDK II UEFI v2.70 (EDK II, 0x00010000) Mapping table FS0: Alias(s):HD0c0:;BLK0: PciRoot(0x0)/Pci(0x19,0x0)/USB(0x2,0x0) Press ESC in 5 seconds to skip startup.nsh or any other key to continue. Shell\u0026gt; FS0: FSOpen: Open \u0026#39;\\\u0026#39; Success FS0:\\\u0026gt; ls Directory of: FS0:\\ 10/17/2023 07:47 4,194,304 uefi.mxd 1 File(s) 4,194,304 bytes 0 Dir(s) FSOpen: Open \u0026#39;\\\u0026#39; Success FS0:\\\u0026gt; spi -u uefi.mxd Erase : ****************************************************************************************** **************************************************************************************************** ****************************************************************** Erase OK. Program : ****************************************************************************************** **************************************************************************************************** ****************************************************************** Program OK. FS0:\\\u0026gt; 在系统下更新固件 # root@loongson-pc:/home/loongson# git clone https://github.com/MarsDoge/OsTools.git root@loongson-pc:/home/loongson# cd OsTools root@loongson-pc:/home/loongson# ./build.sh root@loongson-pc:/home/loongson/OsTools# ./OsTools spi -u -f uefi.mxd mmap addr start : 0xfff78bc1f0 ------------Read Buf Get Success!----------- Erase : [========================================================================] 100% Program : [========================================================================] 100% --------------Release mem Map---------------- root@loongson-pc:/home/loongson/OsTools# reboot 在系统下备份当前固件 # root@loongson-pc:/home/loongson# git clone https://github.com/MarsDoge/OsTools.git root@loongson-pc:/home/loongson# cd OsTools root@loongson-pc:/home/loongson# ./build.sh root@loongson-pc:/home/loongson# ./OsTools spi -d -f backup.dump.fd mmap addr start : 0x7ffff07fc1f0 --------------Release mem Map---------------- root@loongson-pc:/home/loongson# ls backup.dump.fd backup.dump.fd "},{"id":13,"href":"/system/update_system/","title":"如何更新系统","section":"Systems","content":" 1 全系统更新: # Debian系:\napt update \u0026amp;\u0026amp; apt upgrade Redhat系:\nyum update Arch系:\npacman -Syu 安同 OS (AOSC OS)：\noma upgrade 2. 单独更新内核 # 2.1 更新自己编译的内核 # 将内核放置/boot下即可(通常/boot是grub.cfg默认指定的根目录)\n更新完记得更新grub.cfg, 见第四节.\n2.2 更新软件源上的内核 # 以Debian系为例, 其余不做演示:\nroot@loongson-pc:/home/loongson# apt-cache search linux-header aufs-dkms - DKMS files to build and install aufs linux-headers-4.19.0-17-common - Common header files for Linux 4.19 linux-headers-4.19.0-17-loongson-3 - Linux kernel headers for 4.19 on loongson-3 linux-headers-4.19.0-18-common - Common header files for Linux 4.19 linux-headers-4.19.0-18-loongson-3 - Linux kernel headers for 4.19 on loongson-3 linux-headers-4.19.0-19-common - Common header files for Linux 4.19 linux-headers-4.19.0-19-loongson-3 - Linux kernel headers for 4.19 on loongson-3 linux-headers-loongson-3 - Linux kernel headers for 4.19 on loongson-3 (meta-package) root@loongson-pc:/home/loongson# root@loongson-pc:/home/loongson# apt install linux-headers-4.19.0-19-loongson-3 正在读取软件包列表... 完成正在分析软件包的依赖关系树 正在读取状态信息... 完成 ...... ...... 3. 单独更新initrd # 3.1 更新自己编译的modules并生成initrd # 将从内核源码编译的模块文件拷贝至/lib/modules/, 比如4.19.190+.tgz是模块文件的压缩包:\nroot@loongson-pc:/lib/modules# tar -zxf 4.19.190+.tgz -C /lib/modules/ root@loongson-pc:/lib/modules# ls 4.19.0-19-loongson-3 4.19.190+ 在/lib/modules/下生成的4.19.190+文件夹即为新的模块文件目录, 然后手动生成initrd即可. (通常, 模块文件夹名与内核版本名称一致, 倘若不一致, 需要进入/lib/modules/目录, 相当于指定文件夹)\nroot@loongson-pc:/lib/modules# cd /lib/modules/ root@loongson-pc:/lib/modules# dracut --force --kver 4.19.190+ dracut: Executing: /usr/bin/dracut --force --kver 4.19.190+ Mode: real Method: sha256 Files: 1034 Linked: 188 files Compared: 0 xattrs Compared: 2322 files Saved: 7.64 MiB Duration: 0.088150 seconds dracut: *** Hardlinking files done *** dracut: *** Stripping files *** dracut: *** Stripping files done *** dracut: *** Generating early-microcode cpio image *** dracut: *** Store current command line parameters *** dracut: Stored kernel commandline: dracut: resume=UUID=e7429117-dba5-4318-8d48-ab34b7919f6d dracut: root=UUID=103a31fa-631b-4ec5-8295-0817394b36d6 rootfstype=xfs rootflags=rw,noatime,attr2,inode64,noquota dracut: *** Creating image file \u0026#39;/boot/initramfs-4.19.190+.img\u0026#39; *** dracut: *** Creating initramfs image file \u0026#39;/boot/initramfs-4.19.190+.img\u0026#39; done *** /boot/initramfs-4.19.190+.img即为生成的initrd\nmkinitramfs等其他命令不再介绍, 可参考: 生成系统下的一些文件\n3.2 更新软件源上的initrd # 以Debian系为例, 其余不做演示:\nroot@loongson-pc:/lib/modules# apt-cache search linux-image linux-image-4.19.0-17-loongson-3 - Linux kernel, version 4.19 for loongson 3 linux-image-4.19.0-17-loongson-3-dbg - Debug symbols for linux-image-4.19.0-17-loongson-3 linux-image-4.19.0-17-loongson-3-kdump - kdump package linux-image-4.19.0-18-loongson-3 - Linux kernel, version 4.19 for loongson 3 linux-image-4.19.0-18-loongson-3-dbg - Debug symbols for linux-image-4.19.0-18-loongson-3 linux-image-4.19.0-18-loongson-3-kdump - kdump package linux-image-4.19.0-19-loongson-3 - Linux kernel, version 4.19 for loongson 3 linux-image-4.19.0-19-loongson-3-dbg - Debug symbols for linux-image-4.19.0-19-loongson-3 linux-image-4.19.0-19-loongson-3-kdump - kdump package linux-image-loongson-3 - Linux for Loongson 3 (meta-package) linux-image-loongson-3-dbg - Debugging symbols for Linux loongson-3 configuration (meta-package) root@loongson-pc:/lib/modules# apt install linux-image-4.19.0-19-loongson-3 正在读取软件包列表... 完成正在分析软件包的依赖关系树 正在读取状态信息... 完成 ...... ...... 4. 更新grub.cfg # 内核和initrd准备完毕后, 可以增加或修改相应的启动项. 例如vm.mxd是手动编译生成的内核名称. initramfs-4.19.190+.img是根据modules生成的initrd, 增加或者修改相应内容即可:\nmenuentry \u0026#39;vm.mxd\u0026#39; --class loongnix_20 --class gnu-linux --class gnu --class os $menuentry_id_option \u0026#39;gnulinux-simple-103a31fa-631b-4ec5-8295-0817394b36d6\u0026#39; { load_video gfxmode $linux_gfx_mode insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_gpt insmod ext2 set root=\u0026#39;hd0,gpt2\u0026#39; if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-ieee1275=\u0026#39;ieee1275//disk@0,gpt2\u0026#39; --hint-bios=hd0,gpt2 --hint-efi=hd0,gpt2 --hint-baremetal=ahci0,gpt2 6a68fa6e-4fa3-4036-91a3-6f0b2e6ff1b4 else search --no-floppy --fs-uuid --set=root 6a68fa6e-4fa3-4036-91a3-6f0b2e6ff1b4 fi echo \u0026#39;Loading Linux 4.19.0-19-loongson-3 ...\u0026#39; linux /vm.mxd root=UUID=103a31fa-631b-4ec5-8295-0817394b36d6 ro console=ttyS0,115200 earlycon=uart,mmio,0x1fe001e0 splash resume=PARTUUID=5bb18f47-7756-4be9-b5c0-59d1f1d36fed echo \u0026#39;Loading initial ramdisk ...\u0026#39; initrd /initramfs-4.19.190+.img } "},{"id":14,"href":"/system/gen_sys_file/","title":"生成系统下的一些文件","section":"Systems","content":" 1. Initrd # 通常, lib/modules/下的文件夹名称和内核的版本名是一致的, 所以可以通过下列命令生成Initrd:\n1.1 dracut命令 # ls lib/modules/* | xargs -I N dracut --kver N --force 1.2 mkinitramfs命令 # ls lib/modules/* | xargs -I N mkinitramfs /lib/modules/N -o /boot/initrd.img-N 2. GRUB # 2.1 Grub # 通常, Grub安装在当前启动系统所在的磁盘上, 如下命令可以找到当前磁盘. (希望将Grub安装在其他盘的同学, 看明白自己想要的效果)\n[root@mxd ~]# lsblk -P | grep \u0026#34;$(lsblk -P | grep -w \u0026#39;MOUNTPOINTS=\u0026#34;/\u0026#34;\u0026#39; | sed \u0026#39;s/.*MAJ:MIN=\u0026#34;\\([^:]*\\).*/\\1/g\u0026#39;):0\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{print \u0026#34;/dev/\u0026#34; $2}\u0026#39; /dev/nvme0n1 再通过grub-install或者grub2-install命令安装进磁盘:\ngrub-install /dev/nvme0n1 2.2 grub.cfg # grub-mkconfig -o /boot/grub/grub.cfg 2.3 grub.efi # grub-mkimage -c /boot/grub/grub.cfg -o /boot/efi/EFI/BOOT/BOOTLOONGARCH64.EFI -O loongarch64-efi 2.1节中生成grub可以让bios找到启动设备, 自动启动.\n假如没有执行2.1中的内容, 用户可以在UEFI下通过手动执行此节命令中生成的BOOTLOONGARCH64.EFI加载grub程序.\n3. fstab # 系统启动后, 启动参数中的root=后面的内容将被挂载为根文件系统, 也就是Linux目录中的/分区, 而其他的目录的挂载依赖/etc/fstab中的描述, 倘若重新分区, 通常需要更新/etc/fstab中的内容. 里面的内容具体含义详情 https://www.bing.com/\n3.1 自动更新 # 自动更新的前提是对应目录已经按照预设想法挂载, 比如:\n[root@mxd ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 238.5G 0 disk ├─sda1 8:1 0 300M 0 part /boot/efi ├─sda2 8:2 0 300M 0 part /boot ├─sda3 8:3 0 41.3G 0 part / ├─sda4 8:4 0 41.3G 0 part ├─sda5 8:5 0 146.5G 0 part /root │ /opt │ /home │ /var │ /data └─sda6 8:6 0 8.8G 0 part [SWAP] 然后使用github上开源的genfstab工具生成:\n[root@mxd ~]# git clone https://github.com/glacion/genfstab.git 正克隆到 \u0026#39;genfstab\u0026#39;... remote: Enumerating objects: 14, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (3/3), done. remote: Total 14 (delta 0), reused 1 (delta 0), pack-reused 11 接收对象中: 100% (14/14), 29.18 KiB | 281.00 KiB/s, 完成. 处理 delta 中: 100% (2/2), 完成. [root@mxd ~]# cd genfstab/ [root@mxd ~ genfstab]# ./genfstab -U \u0026gt; /etc/fstab 同样, 假如在制作非当前启动系统的fstab文件, 例如:\n[root@mxd ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 238.5G 0 disk ├─sda1 8:1 0 300M 0 part /mnt/boot/efi ├─sda2 8:2 0 300M 0 part /mnt/boot ├─sda3 8:3 0 82.6G 0 part /mnt ├─sda4 8:5 0 146.5G 0 part /mnt/home └─sda5 8:6 0 8.8G 0 part [SWAP] 也同样可以使用:\n[root@mxd ~ genfstab]# ./genfstab -U \u0026gt; /mnt/etc/fstab 3.2 手动更新 # 同样, 假如在制作非当前启动系统的fstab文件, 例如:\n[root@mxd ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 238.5G 0 disk ├─sda1 8:1 0 300M 0 part /mnt/boot/efi ├─sda2 8:2 0 300M 0 part /mnt/boot ├─sda3 8:3 0 82.6G 0 part /mnt ├─sda4 8:5 0 146.5G 0 part /mnt/home └─sda5 8:6 0 8.8G 0 part [SWAP] [root@mxd ~]# blkid /dev/sda2: LABEL=\u0026#34;bootfs\u0026#34; UUID=\u0026#34;6a68fa6e-4fa3-4036-91a3-6f0b2e6ff1b4\u0026#34; BLOCK_SIZE=\u0026#34;1024\u0026#34; TYPE=\u0026#34;ext3\u0026#34; PARTUUID=\u0026#34;2215dfd8\u0026#34; /dev/sda4: LABEL=\u0026#34;datafs\u0026#34; UUID=\u0026#34;b4e5345f-171e-447c-8b89-52459b29a380\u0026#34; BLOCK_SIZE=\u0026#34;512\u0026#34; TYPE=\u0026#34;xfs\u0026#34; PARTUUID=\u0026#34;0ba0e5ea-a\u0026#34; /dev/sda3: LABEL=\u0026#34;rootfs\u0026#34; UUID=\u0026#34;103a31fa-631b-4ec5-8295-0817394b36d6\u0026#34; BLOCK_SIZE=\u0026#34;512\u0026#34; TYPE=\u0026#34;xfs\u0026#34; PARTUUID=\u0026#34;687bdb73-3\u0026#34; /dev/sda1: UUID=\u0026#34;768C-0E8F\u0026#34; BLOCK_SIZE=\u0026#34;512\u0026#34; TYPE=\u0026#34;vfat\u0026#34; PARTUUID=\u0026#34;bbb4bdad-36d3-4300-872c-1c00b15588c2\u0026#34; /dev/sda5: UUID=\u0026#34;e7429117-dba5-4318-8d48-ab34b7919f6d\u0026#34; TYPE=\u0026#34;swap\u0026#34; PARTUUID=\u0026#34;5bb18f47-7756-4be9-b5c0-59d1f1d36fed\u0026#34; 只需要将对应分区的UUID填写到/mnt/etc/fstab中去.\n第一列是UUID, 或者理解是挂载的来源\n第二列是挂载的目标位置\n第三列是挂载的类型\n第四列是挂载的参数\n[root@mxd ~]# cat /mnt/etc/fstab # /etc/fstab: static file system information. # # Use \u0026#39;blkid\u0026#39; to print the universally unique identifier for a device; this may # be used with UUID= as a more robust way to name devices that works even if # disks are added and removed. See fstab(5). # # \u0026lt;file system\u0026gt; \u0026lt;mount point\u0026gt; \u0026lt;type\u0026gt; \u0026lt;options\u0026gt; \u0026lt;dump\u0026gt; \u0026lt;pass\u0026gt; UUID=768C-0E8F /boot/efi vfat defaults,noatime 0 2 UUID=6a68fa6e-4fa3-4036-91a3-6f0b2e6ff1b4 /boot ext3 defaults,noatime 0 2 UUID=103a31fa-631b-4ec5-8295-0817394b36d6 / xfs defaults,noatime,discard 0 1 UUID=b4e5345f-171e-447c-8b89-52459b29a380 /home xfs defaults,noatime,discard 0 2 UUID=e7429117-dba5-4318-8d48-ab34b7919f6d swap swap defaults,noatime 0 2 tmpfs /tmp tmpfs defaults,noatime,mode=1777 0 0 其中第四列挂载的参数可以参考mount -v的输出, 不清楚的抄一抄上述内容, 基本是可用的.\n4. 生成用户 # 其实是创建用户, 任何系统都需要一个可登录的用户来操作, 那么则必须配置一个用户作为登录选项.\n开发中常用root帐号通常是自带的, 但是我们需要对其设定密码, 通过passwd root命令.\n如果我们需要普通用户, 则需要通过useradd命令创建:\n[root@mxd ~]# useradd -m -s /bin/bash username [root@mxd ~]# passwd username 新的密码： 重新输入新的密码： passwd：已成功更新密码 通常, 上述内容是制作一个操作系统最基本的内容(个人理解, 非专业说明).\n"},{"id":15,"href":"/system/systeminfo/","title":"系统下查看一些信息","section":"Systems","content":" 1. 查看系统版本 # [root@mxd mxd]# cat /etc/os-release NAME=\u0026#34;Arch Linux\u0026#34; PRETTY_NAME=\u0026#34;Arch Linux\u0026#34; ID=arch BUILD_ID=rolling ANSI_COLOR=\u0026#34;38;2;23;147;209\u0026#34; HOME_URL=\u0026#34;https://archlinux.org/\u0026#34; DOCUMENTATION_URL=\u0026#34;https://wiki.archlinux.org/\u0026#34; SUPPORT_URL=\u0026#34;https://bbs.archlinux.org/\u0026#34; BUG_REPORT_URL=\u0026#34;https://bugs.archlinux.org/\u0026#34; PRIVACY_POLICY_URL=\u0026#34;https://terms.archlinux.org/docs/privacy-policy/\u0026#34; LOGO=archlinux-logo 2. 查看内核版本 # [root@mxd mxd]# uname -a Linux mxd 6.5.0-4 #1 SMP PREEMPT Thu, 31 Aug 2023 09:38:08 +0000 loongarch64 GNU/Linux 3. 查看固件版本 # [root@mxd mxd]# cat /sys/firmware/loongson/boardinfo BIOS Information Vendor\t: Loongson Version\t: Loongson-UDK2018-V4.0.05494-stable202305 ROM Size\t: 4096 KB Release Date\t: 07/10/23 18:05:47 Board Information Manufacturer\t: Loongson Board Name\t: Loongson-LS3A6000-7A2000-1w-EVB-V1.21 Family\t: LOONGSON64 4. 查看ip # [root@mxd mxd]# ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host noprefixroute valid_lft forever preferred_lft forever 2: enp0s3f0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether 00:55:7b:b5:7d:f7 brd ff:ff:ff:ff:ff:ff 3: enp2s0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether ce:38:b3:df:3b:23 brd ff:ff:ff:ff:ff:ff inet 192.168.1.13/23 brd 192.168.1.255 scope global dynamic noprefixroute enp2s0 valid_lft 40218sec preferred_lft 40218sec inet6 fe80::80b6:e9f0:ab6c:e9c5/64 scope link noprefixroute valid_lft forever preferred_lft forever 4: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:4e:12:01:c7 brd ff:ff:ff:ff:ff:ff inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0 valid_lft forever preferred_lft forever 5. 查看pci设备 # [root@mxd mxd]# lspci 00:00.0 Host bridge: Loongson Technology LLC Hyper Transport Bridge Controller 00:00.1 Host bridge: Loongson Technology LLC Hyper Transport Bridge Controller (rev 01) 00:00.2 Host bridge: Loongson Technology LLC Device 7a20 (rev 01) 00:00.3 Host bridge: Loongson Technology LLC Device 7a30 00:03.0 Ethernet controller: Loongson Technology LLC Device 7a13 00:04.0 USB controller: Loongson Technology LLC OHCI USB Controller (rev 02) 00:04.1 USB controller: Loongson Technology LLC EHCI USB Controller (rev 02) 00:05.0 USB controller: Loongson Technology LLC OHCI USB Controller (rev 02) 00:05.1 USB controller: Loongson Technology LLC EHCI USB Controller (rev 02) 00:06.0 Multimedia video controller: Loongson Technology LLC Device 7a25 (rev 01) 00:06.1 VGA compatible controller: Loongson Technology LLC Device 7a36 (rev 02) 00:06.2 Audio device: Loongson Technology LLC Device 7a37 00:07.0 Audio device: Loongson Technology LLC HDA (High Definition Audio) Controller 00:08.0 SATA controller: Loongson Technology LLC Device 7a18 00:09.0 PCI bridge: Loongson Technology LLC Device 7a49 00:0a.0 PCI bridge: Loongson Technology LLC Device 7a39 00:0b.0 PCI bridge: Loongson Technology LLC Device 7a39 00:0c.0 PCI bridge: Loongson Technology LLC Device 7a39 00:0d.0 PCI bridge: Loongson Technology LLC Device 7a49 00:0f.0 PCI bridge: Loongson Technology LLC Device 7a69 00:10.0 PCI bridge: Loongson Technology LLC Device 7a59 00:13.0 PCI bridge: Loongson Technology LLC Device 7a59 00:16.0 System peripheral: Loongson Technology LLC Device 7a1b 00:19.0 USB controller: Loongson Technology LLC Device 7a34 02:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller (rev 15) 05:00.0 Non-Volatile memory controller: Shenzhen Longsys Electronics Co., Ltd. SM2263EN/SM2263XT-based OEM SSD (rev 03) 07:00.0 VGA compatible controller: Advanced Micro Devices, Inc. [AMD/ATI] Oland [Radeon HD 8570 / R5 430 OEM / R7 240/340 / Radeon 520 OEM] (rev 87) 07:00.1 Audio device: Advanced Micro Devices, Inc. [AMD/ATI] Oland/Hainan/Cape Verde/Pitcairn HDMI Audio [Radeon HD 7000 Series] 5.1 详细查看某pci设备使用的驱动 # 其中07:00.0是上面左侧显示的一段数字, 根据描述, 07:00.0那一行指一个VGA兼容设备, 换句话说是指显示设备, 业内叫做显卡\n如下, 该显卡使用的驱动是:radeon\n[root@mxd mxd]# lspci -vvv -s 07:00.0 2\u0026gt;/dev/null | grep driver -A 2 Kernel driver in use: radeon 6. 查看系统下某驱动是否加载 # 如下显示:\n第1列：表示模块的名称，如radeon表示radeon模块。\n第2列：表示模块的大小，如1687552表示radeon模块的大小为1687552字节。\n第3列：表示依赖模块的个数，如74表示radeon有74个依赖模块。\n第4列：表示依赖模块的内容, 如drm_suballoc_helper依赖于amdgpu,radeon俩模块\n[root@mxd mxd]# lsmod | grep radeon radeon 1687552 74 drm_suballoc_helper 49152 2 amdgpu,radeon drm_ttm_helper 49152 2 amdgpu,radeon ttm 131072 3 amdgpu,radeon,drm_ttm_helper drm_display_helper 229376 2 amdgpu,radeon drm_kms_helper 229376 5 drm_dma_helper,drm_display_helper,amdgpu,radeon,loongson 7. 查看系统启动log # 当不确定开发人员需要哪些信息时, 请优先将此信息给出.\n[root@mxd mxd]# dmesg [ 2.248064] ATOM BIOS: C57701 [ 2.248176] radeon 0000:07:00.0: VRAM: 2048M 0x0000000000000000 - 0x000000007FFFFFFF (2048M used) [ 2.248179] radeon 0000:07:00.0: GTT: 2048M 0x0000000080000000 - 0x00000000FFFFFFFF [ 2.248180] [drm] Detected VRAM RAM=2048M, BAR=256M [ 2.248182] [drm] RAM width 64bits DDR [ 2.248289] [drm] radeon: 2048M of VRAM memory ready [ 2.248292] [drm] radeon: 2048M of GTT memory ready. [ 2.248300] [drm] Loading oland Microcode [ 2.249595] [drm] Internal thermal controller with fan control [ 2.259143] [drm] radeon: dpm initialized [ 2.261098] [drm] GART: num cpu pages 131072, num gpu pages 524288 [ 2.261845] [drm] PCIE gen 3 link speeds already enabled [ 2.328096] [drm] PCIE GART of 2048M enabled (table at 0x0000000000168000). [ 2.328289] radeon 0000:07:00.0: WB enabled [ 2.328291] radeon 0000:07:00.0: fence driver on ring 0 use gpu addr 0x0000000080000c00 [ 2.328293] radeon 0000:07:00.0: fence driver on ring 1 use gpu addr 0x0000000080000c04 [ 2.328294] radeon 0000:07:00.0: fence driver on ring 2 use gpu addr 0x0000000080000c08 [ 2.328296] radeon 0000:07:00.0: fence driver on ring 3 use gpu addr 0x0000000080000c0c [ 2.328297] radeon 0000:07:00.0: fence driver on ring 4 use gpu addr 0x0000000080000c10 [ 2.343597] radeon 0000:07:00.0: fence driver on ring 5 use gpu addr 0x0000000000075a18 [ 2.343678] radeon 0000:07:00.0: radeon: MSI limited to 32-bit ...... ...... 或:\n[root@mxd mxd]# journalctl -b -0 10月 11 09:16:21 mxd kernel: Linux version 6.5.0-4 (linux@archlinux) (gcc (GCC) 13.2.1 20230801, GNU ld (GNU Binutils)\u0026gt; 10月 11 09:16:21 mxd kernel: 64-bit Loongson Processor probed (LA664 Core) 10月 11 09:16:21 mxd kernel: CPU0 revision is: 0014d000 (Loongson-64bit) 10月 11 09:16:21 mxd kernel: FPU0 revision is: 00000000 10月 11 09:16:21 mxd kernel: efi: EFI v2.7 by EDK II 10月 11 09:16:21 mxd kernel: efi: ACPI 2.0=0xfa3b0000 SMBIOS 3.0=0xfe5b0000 INITRD=0xfa2d0e98 MEMRESERVE=0xfa2d0d98 ME\u0026gt; 10月 11 09:16:21 mxd kernel: ACPI: Early table checksum verification disabled 10月 11 09:16:21 mxd kernel: ACPI: RSDP 0x00000000FA3B0000 000024 (v02 LOONGS) 10月 11 09:16:21 mxd kernel: ACPI: XSDT 0x00000000FA3A0000 000064 (v01 LOONGS LOONGSON 00000002 01000013) 10月 11 09:16:21 mxd kernel: ACPI: FACP 0x00000000FA370000 0000F4 (v03 LOONGS LOONGSON 00000002 LIUX 01000013) 10月 11 09:16:21 mxd kernel: ACPI: DSDT 0x00000000FA340000 002676 (v02 LOONGS LOONGSON 00000002 INTL 20180629) 10月 11 09:16:21 mxd kernel: ACPI: FACS 0x00000000FA380000 000040 10月 11 09:16:21 mxd kernel: ACPI: APIC 0x00000000FA390000 0000FA (v01 LOONGS LOONGSON 00000002 LIUX 01000013) 10月 11 09:16:21 mxd kernel: ACPI: IVRS 0x00000000FA360000 00004C (v01 LARCH LOONGSON 00000001 LIUX 00000001) 10月 11 09:16:21 mxd kernel: ACPI: MCFG 0x00000000FA350000 00003C (v01 LOONGS LOONGSON 00000001 LIUX 01000013) 10月 11 09:16:21 mxd kernel: ACPI: SRAT 0x00000000FA330000 000100 (v02 LOONGS LOONGSON 00000002 LIUX 01000013) 10月 11 09:16:21 mxd kernel: ACPI: SLIT 0x00000000FA320000 00002D (v01 LOONGS LOONGSON 00000002 LIUX 01000013) 10月 11 09:16:21 mxd kernel: ACPI: VIAT 0x00000000FA310000 00002C (v01 LOONGS LOONGSON 00000002 LIUX 01000013) 10月 11 09:16:21 mxd kernel: ACPI: PPTT 0x00000000FA300000 000128 (v03 LOONGS LOONGSON 00000002 LIUX 01000013) ...... ...... 两种打印不一致是因为dmesg命令显示的内容是从2秒开始的, 前面的内容被冲掉了, 而journalctl显示的内容则更完整.\n7.1 查看系统上一次的启动log # [root@mxd mxd]# journalctl -b -1 9月 06 16:19:37 mxd kernel: Linux version 6.5.0-4 (linux@archlinux) (gcc (GCC) 13.2.1 20230801, GNU ld (GNU Binutils) \u0026gt; 9月 06 16:19:37 mxd kernel: 64-bit Loongson Processor probed (LA664 Core) 9月 06 16:19:37 mxd kernel: CPU0 revision is: 0014d000 (Loongson-64bit) 9月 06 16:19:37 mxd kernel: FPU0 revision is: 00000000 9月 06 16:19:37 mxd kernel: efi: EFI v2.7 by EDK II 9月 06 16:19:37 mxd kernel: efi: ACPI 2.0=0xfa3b0000 SMBIOS 3.0=0xfe5b0000 INITRD=0xfa2d0e98 MEMRESERVE=0xfa2d0d18 MEM\u0026gt; 9月 06 16:19:37 mxd kernel: ACPI: Early table checksum verification disabled 9月 06 16:19:37 mxd kernel: ACPI: RSDP 0x00000000FA3B0000 000024 (v02 LOONGS) 9月 06 16:19:37 mxd kernel: ACPI: XSDT 0x00000000FA3A0000 000064 (v01 LOONGS LOONGSON 00000002 01000013) 9月 06 16:19:37 mxd kernel: ACPI: FACP 0x00000000FA370000 0000F4 (v03 LOONGS LOONGSON 00000002 LIUX 01000013) 9月 06 16:19:37 mxd kernel: ACPI: DSDT 0x00000000FA340000 002676 (v02 LOONGS LOONGSON 00000002 INTL 20180629) 9月 06 16:19:37 mxd kernel: ACPI: FACS 0x00000000FA380000 000040 9月 06 16:19:37 mxd kernel: ACPI: APIC 0x00000000FA390000 0000FA (v01 LOONGS LOONGSON 00000002 LIUX 01000013) 9月 06 16:19:37 mxd kernel: ACPI: IVRS 0x00000000FA360000 00004C (v01 LARCH LOONGSON 00000001 LIUX 00000001) 9月 06 16:19:37 mxd kernel: ACPI: MCFG 0x00000000FA350000 00003C (v01 LOONGS LOONGSON 00000001 LIUX 01000013) 9月 06 16:19:37 mxd kernel: ACPI: SRAT 0x00000000FA330000 000100 (v02 LOONGS LOONGSON 00000002 LIUX 01000013) 9月 06 16:19:37 mxd kernel: ACPI: SLIT 0x00000000FA320000 00002D (v01 LOONGS LOONGSON 00000002 LIUX 01000013) 9月 06 16:19:37 mxd kernel: ACPI: VIAT 0x00000000FA310000 00002C (v01 LOONGS LOONGSON 00000002 LIUX 01000013) 9月 06 16:19:37 mxd kernel: ACPI: PPTT 0x00000000FA300000 000128 (v03 LOONGS LOONGSON 00000002 LIUX 01000013) ...... ...... 8. 查看磁盘挂载信息 # [root@mxd mxd]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 931.5G 0 disk ├─sda1 8:1 0 500M 0 part ├─sda2 8:2 0 1G 0 part ├─sda3 8:3 0 500G 0 part └─sda4 8:4 0 430G 0 part /work nvme0n1 259:0 0 238.5G 0 disk ├─nvme0n1p1 259:1 0 300M 0 part /boot/efi ├─nvme0n1p2 259:2 0 300M 0 part /boot ├─nvme0n1p3 259:3 0 80G 0 part / ├─nvme0n1p4 259:4 0 150.4G 0 part /home └─nvme0n1p5 259:5 0 7.5G 0 part 9. 查看磁盘使用信息 # [root@mxd mxd]# df -h 文件系统 大小 已用 可用 已用% 挂载点 dev 7.9G 0 7.9G 0% /dev run 7.9G 6.2M 7.9G 1% /run efivarfs 59K 14K 46K 23% /sys/firmware/efi/efivars /dev/nvme0n1p3 80G 16G 65G 20% / tmpfs 7.9G 338M 7.6G 5% /dev/shm tmpfs 7.9G 1.9G 6.1G 24% /tmp /dev/nvme0n1p4 150G 99G 52G 66% /home /dev/nvme0n1p2 272M 110M 147M 43% /boot /dev/nvme0n1p1 300M 196K 300M 1% /boot/efi /dev/sda4 430G 22G 408G 6% /work tmpfs 1.6G 608K 1.6G 1% /run/user/1000 10. 查看内存使用情况 # [root@mxd mxd]# free -m total used free shared buff/cache available 内存： 16146 13354 1372 2354 5945 2792 交换： 0 0 0 11. 查看系统某服务运行情况 # 比如NetworkManager服务\n[root@mxd mxd]# systemctl status NetworkManager ● NetworkManager.service - Network Manager Loaded: loaded (/usr/lib/systemd/system/NetworkManager.service; enabled; preset: disabled) Active: active (running) since Wed 2023-10-11 09:16:23 CST; 2 weeks 1 day ago Docs: man:NetworkManager(8) Main PID: 2746 (NetworkManager) Tasks: 4 (limit: 19334) Memory: 10.7M CPU: 8min 57.592s CGroup: /system.slice/NetworkManager.service └─2746 /usr/bin/NetworkManager --no-daemon 10月 26 09:20:04 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698283204.0241] manager: NetworkManager state is now CONNECTED_GL\u0026gt; 10月 26 09:22:31 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698283351.8060] dhcp4 (enp2s0): state changed new lease, address=\u0026gt; 10月 26 09:35:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698284123.6465] manager: NetworkManager state is now CONNECTED_SI\u0026gt; 10月 26 09:39:39 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698284379.0202] manager: NetworkManager state is now CONNECTED_GL\u0026gt; 10月 26 09:49:58 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698284998.6470] manager: NetworkManager state is now CONNECTED_SI\u0026gt; 10月 26 09:54:14 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698285254.0105] manager: NetworkManager state is now CONNECTED_GL\u0026gt; 10月 26 10:04:33 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698285873.6467] manager: NetworkManager state is now CONNECTED_SI\u0026gt; 10月 26 10:05:06 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1698285906.0615] manager: NetworkManager state is now CONNECTED_GL\u0026gt; 11.1 查看某服务的运行log # 比如NetworkManager服务\n[root@mxd mxd]# journalctl -b -u NetworkManager 10月 11 09:16:23 mxd systemd[1]: Starting Network Manager... 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.3066] NetworkManager (version 1.42.6-1) is starting... \u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.3069] Read config: /etc/NetworkManager/NetworkManager.c\u0026gt; 10月 11 09:16:23 mxd systemd[1]: Started Network Manager. 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.3090] bus-manager: acquired D-Bus service \u0026#34;org.freedesk\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.3143] manager[0x5555767b5ec0]: monitoring kernel firmwa\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5504] hostname: hostname: using hostnamed 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5505] hostname: static hostname changed from (none) to \u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5509] dns-mgr: init: dns=default,systemd-resolved rc-ma\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5529] manager[0x5555767b5ec0]: rfkill: Wi-Fi hardware r\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5529] manager[0x5555767b5ec0]: rfkill: WWAN hardware ra\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5566] Loaded device plugin: NMAtmManager (/usr/lib/Netw\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5615] Loaded device plugin: NMBluezManager (/usr/lib/Ne\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5627] Loaded device plugin: NMOvsFactory (/usr/lib/Netw\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5831] Loaded device plugin: NMTeamFactory (/usr/lib/Net\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5842] Loaded device plugin: NMWifiFactory (/usr/lib/Net\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5849] Loaded device plugin: NMWwanFactory (/usr/lib/Net\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5851] manager: rfkill: Wi-Fi enabled by radio killswitc\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5852] manager: rfkill: WWAN enabled by radio killswitch\u0026gt; 10月 11 09:16:23 mxd NetworkManager[2746]: \u0026lt;info\u0026gt; [1696986983.5852] manager: Networking is enabled by state file ...... ...... 12. 查看USB连接信息 # [root@mxd mxd]# lsusb -t /: Bus 06.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 5000M /: Bus 05.Port 1: Dev 1, Class=root_hub, Driver=xhci_hcd/4p, 480M /: Bus 04.Port 1: Dev 1, Class=root_hub, Driver=ohci-pci/4p, 12M |__ Port 2: Dev 7, If 0, Class=Vendor Specific Class, Driver=pl2303, 12M /: Bus 03.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/4p, 480M |__ Port 1: Dev 103, If 0, Class=Hub, Driver=hub/4p, 480M |__ Port 1: Dev 104, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M |__ Port 3: Dev 105, If 0, Class=Human Interface Device, Driver=usbhid, 1.5M |__ Port 3: Dev 105, If 1, Class=Human Interface Device, Driver=usbhid, 1.5M /: Bus 02.Port 1: Dev 1, Class=root_hub, Driver=ohci-pci/4p, 12M |__ Port 1: Dev 4, If 0, Class=Vendor Specific Class, Driver=pl2303, 12M /: Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/4p, 480M 13. 查看CPU相关信息 # [root@mxd mxd]# lscpu 架构： loongarch64 CPU 运行模式： 32-bit, 64-bit Address sizes: 48 bits physical, 48 bits virtual 字节序： Little Endian CPU: 8 在线 CPU 列表： 0-7 BIOS 厂商 ID： Loongson 型号名称： Loongson-3A6000 BIOS 型号名称： Loongson-3A6000 Not Specified CPU @ 2.5GHz BIOS CPU family: 603 CPU 系列： Loongson-64bit 型号： 0x00 每个核的线程数： 2 每个座的核数： 4 座： 1 BogoMIPS： 5000.00 标记： cpucfg lam ual fpu lsx lasx crc32 complex crypto lvz lbt_x86 lbt_arm lbt_mips Caches (sum of all): L1d: 512 KiB (8 instances) L1i: 512 KiB (8 instances) L2: 2 MiB (8 instances) L3: 16 MiB (1 instance) NUMA: NUMA 节点： 1 NUMA 节点0 CPU： 0-7 以及:\n[root@mxd mxd]# cat /proc/cpuinfo system type\t: generic-loongson-machine processor\t: 0 package\t: 0 core\t: 0 global_id\t: 0 CPU Family\t: Loongson-64bit Model Name\t: Loongson-3A6000 CPU Revision\t: 0x00 FPU Revision\t: 0x00 CPU MHz\t: 2500.00 BogoMIPS\t: 5000.00 TLB Entries\t: 2112 Address Sizes\t: 48 bits physical, 48 bits virtual ISA\t: loongarch32 loongarch64 Features\t: cpucfg lam ual fpu lsx lasx crc32 complex crypto lvz lbt_x86 lbt_arm lbt_mips Hardware Watchpoint\t: yes, iwatch count: 8, dwatch count: 4 ...... ...... 14. 查看SMBIOS详细信息 # [root@mxd mxd]# dmidecode # dmidecode 3.5 Getting SMBIOS data from sysfs. SMBIOS 3.2.0 present. Table at 0xFE5A0000. Handle 0x0000, DMI type 0, 26 bytes BIOS Information Vendor: Loongson Version: Loongson-UDK2018-V4.0.05494-stable202305 Release Date: 07/10/23 18:05:47 ROM Size: 4 MB Characteristics: PCI is supported BIOS is upgradeable Boot from CD is supported Selectable boot is supported BIOS ROM is socketed Serial services are supported (int 14h) USB legacy is supported UEFI is supported BIOS Revision: 4.0 Handle 0x0001, DMI type 1, 27 bytes System Information Manufacturer: Loongson Product Name: Loongson-3A6000-7A2000-1w-V0.1-EVB Version: Not Specified Serial Number: Not Specified UUID: Not Present Wake-up Type: Power Switch SKU Number: Not Specified Family: Not Specified ...... ...... 可以使用-t参数只看某一项信息\n如查看processor信息:\n[root@mxd mxd]# dmidecode -t processor # dmidecode 3.5 Getting SMBIOS data from sysfs. SMBIOS 3.2.0 present. Handle 0x0004, DMI type 4, 48 bytes Processor Information Socket Designation: CPU0 Type: Central Processor Family: \u0026lt;OUT OF SPEC\u0026gt; Manufacturer: Loongson ID: 33 41 36 30 30 30 00 00 Version: Loongson-3A6000 Voltage: Unknown External Clock: Unknown Max Speed: Unknown Current Speed: 2500 MHz Status: Populated, Enabled Upgrade: \u0026lt;OUT OF SPEC\u0026gt; L1 Cache Handle: Not Provided L2 Cache Handle: Not Provided L3 Cache Handle: Not Provided Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Core Count: 8 Core Enabled: 8 Thread Count: 8 Characteristics: 64-bit capable Multi-Core Hardware Thread 15. 查看媒体文件信息 # [root@mxd video_test]# mediainfo yangman.wav General Complete name : yangman.wav Format : Wave Format settings : PcmWaveformat File size : 43.4 MiB Duration : 3 min 56 s Overall bit rate mode : Constant Overall bit rate : 1 541 kb/s Album : 少年 Track name : 少年 Track name/Position : 1 Performer : 梦然 Director : ÃÎÈ» Genre : pop Recorded date : 2019 Original source form/Name : ÉÙÄê Copyright : 夏星星收藏 Cover : Yes Cover type : Cover (front) Cover MIME : image/jpeg ITRK : 1 iurl : http://user.qzone.qq.com/ Audio Format : PCM Format settings : Little / Signed Codec ID : 1 Duration : 3 min 56 s Bit rate mode : Constant Bit rate : 1 536 kb/s Channel(s) : 2 channels Sampling rate : 48.0 kHz Bit depth : 16 bits Stream size : 43.2 MiB (100%) 16. 查看文件 # 16.1 产看文件类型 # [root@mxd video_test]# file yangman.wav yangman.wav: RIFF (little-endian) data, WAVE audio, Microsoft PCM, 16 bit, stereo 48000 Hz 16.2 查看文件大小 # [root@mxd video_test]# du -sh yangman.wav 44M\tyangman.wav 16.3 查看文件校验码 # 如md5:\n[root@mxd video_test]# md5sum yangman.wav 07c75d425e152d3ef782a8dd4b420ab7 yangman.wav 17. 查看网络端口信息 # [root@mxd video_test]# netstat -tnup | grep 3389 tcp6 0 0 192.168.1.3:3389 192.168.1.4:59708 ESTABLISHED - "},{"id":16,"href":"/system/install_archlinux/","title":"新世界Archlinux系统安装","section":"Systems","content":" 转载文章来源： https://bbs.loongarch.org/d/88-archlinux/28\n本主题多人协作，版主权限可编辑，开源爱好者若要参与协作，可回复中申请权限，或者在QQ群里申请。 # 为了协调一致，本指南基于 @yetist制作的可引导安装镜像，指南覆盖系统引导、安装和具体应用配置。安装配置中遇到的问题，可以在回复中提出。本主题多人协作持续更新，勿催，谢谢！ # 一、龙芯新固件环境下引导盘的制作 # 安装镜像及软件仓库动态，可在如下主题中找到 # https://bbs.loongarch.org/d/67-loongarchlinux-202203/30\n最新镜像下载，随时更新 # https://mirrors.wsyu.edu.cn/loongarch/2022.03/iso/2022.06/loongarchlinux-2022.06.16.1-loongarch64.iso\nhttps://mirrors.wsyu.edu.cn/loongarch/2022.03/iso/2022.06/loongarchlinux-2022.06.22.1-loongarch64.iso\nhttps://mirrors.wsyu.edu.cn/loongarch/archlinux/iso/latest/archlinux-loong64.iso\n引导盘制作 # 准备工作：一块确定状态良好的U盘，容量4G以上即可，制作引导U盘会擦除盘内原始数据，注意备份。\nLinux环境下，插入U盘，系统会识别，不要做任何打开，加载等操作，具体设备名，可使用如下命令\nls -la /dev/sd* ## U盘一般会识别成硬盘设备，*表示系统动态赋予的一个字符，用以区分不同硬盘 Linux环境下，使用dd这个工具软件 # 注意：x是个字符，用实际内容替换，命令执行需要root用户权限 sudo dd if=loongarchlinux-xxx.iso of=/dev/sdx bs=1M status=progress oflag=direct # 命令执行完成后，建议运行下如下命令，确保U盘写入完整 sudo sync 二、系统引导和安装前的检查 # 使用新固件引导，有两个快捷键会经常用到：\nF2 ----- 激活固件配置界面，可在配置界面的选择引导设备 F12 ----- 激活引导管理菜单，暂时不推荐使用这个方式选择引导设备 使用新固件引导系统，包括引导本主题中制作好的U盘和之前使用grub有区别，具体流程是：\n1、开机前把制作好的U盘插入机器USB接口，建议插入到主板提供的接口上，不建议使用前置接口，躲坑。\n2、开机后出现龙芯logo，快速按F2，直到进入固件配置界面\n3、按如下图示操作：\n\u0026hellip;\nTODO: 需要补充英文界面操作，或说明修改语言方法。\n移动光标到 启动管理 项，回车：\n进入 启动管理 菜单之后，将会看到一系列可选择的启动项，请在列表中找到 EFI System Partition 或 EFI System Partition 2，并选择此项启动：\n如果在 启动管理 界面选择对了正确的启动项，电脑将会从U盘启动，如果看到显示器上出现了以下黑色背景的菜单项，则说明从 U 盘引导成功。\n在这个界面出现后，请选择带有 LoongArchLinux 的菜单项，一般使用第1个就可以，电脑将开始从U 盘上启动系统。\n当看到如下界面出现时，说明已经进入了 ArchLinux 安装环境，可以开始安装系统了。\n三、安装到机内硬盘 # 分区和格式化 # 分区和挂载也可以参考 凌莞的分区方案\n1、磁盘分区操作 # 安装引导盘提供的分区工具比较多，常用的fdisk,cfdisk,gpart都有提供，推荐使用cfdisk，文本图形界面。\n重要：分区和格式化后，磁盘（机械硬盘、固态硬盘和U盘）原有信息会被清除，友情提示谨慎操作，一定要确定好使用哪块硬盘，要记住它的设备名，如果是sata接口，或者U盘，设备名一般是sda、sdb、sdc，固态情况要复杂些，但也很好辨认。本指南预设目标磁盘是 sdx ，x 字符根据实际需要选择！\n预备知识：sdx磁盘分区后，会生成 sdx1、sdx2 \u0026hellip; sdxn，数字表示的是第几个分区。分区操作执行完成后，可执行如下命令：\nls -la /dev/sd* # 命令会列出所有识别出来的硬盘设备，也可以验证分区是否成功 分区的具体操作：\ncfdisk /dev/sdx 输入命令回车后，会出现一个全屏界面，里面显示的是分区列表，屏幕下面是几个按钮\n具体操作，选择分区用上下箭头，用tab键和左右键可选择屏幕下面的按钮，回车确定\n提示：所有操作都会在 write 后生效，所以要再次检查下分区布局\n如果原来的分区都要放弃，全盘切入到新固件新环境，有个便捷的方法 # cfdisk -z /dev/sdx 它会清空你选定的设备的所有分区，一切从头来过\n分区的结果：\n一个EFI分区，多个linux分区\n建议：EFI分区容量200M不少，1G也不多，创建这个分区时，在cfdisk里，可以指定分区类型，选第一个EFI即可\n可以考虑建一个8G或16G的分区，后续把这个分区当交换分区用\n2、分区格式化操作 # 本例中使用的磁盘是sata接口的固态硬盘，所以系统识别为sdb，配置了6个分区，sdb1是efi分区，sdb3是要准备使用的root分区，sdb5准备当成交换分区，具体的格式化操作是：\nmkfs.fat /dev/sdb1 # 将 ESP 分区格式化成 fat 文件格式，这是EFI分区的要求 mkfs.ext4 /dev/sdb3 # 将根分区格式化成 ext4 文件格式，这样更加稳定简单 mkswap /dev/sdb5 # 制作交换分区 swapon /dev/sdb5 # 交换分区使能 安装必要的基础组件 # 1、分区挂载 # 进行到这个步骤，算是完成了前期的准备工作，后续是要真正安装archlinux了，建议确认如下事项：\npacman -Syy # 检测下网络，并确认所需工具能正常使用 lsblk # 检查下磁盘分区，是否有效 接下来要做的是把准备好的分区进行挂载，以便往磁盘里安装组件，一般情况下建议使用 /mnt 这个挂载点\ncd / # 到根目录 mount /dev/sdb3 /mnt # 把准备好的根分区，挂载到 /mnt 上 mkdir /mnt/boot # 在/mnt目录下，建立一个boot目录，用于挂载efi分区 mount /dev/sdb1 /mnt/boot # 挂载efi分区到 /mnt/boot上 可以运行如下命令确认下挂载情况\ndf # 如果能看到 /mnt 对应 sdb3 以及 /mnt/boot 对应sdb1，说明挂载成功 2、使用pacstrap安装必须组件 # pacstrap /mnt base base-devel linux linux-headers linux-firmware vi nano dhcpcd networkmanager 这个命令会启动下载安装到硬盘过程，时间长短受网络状况影响，需要等待，这个时间可以边休憩边看下载和安装这两个过程是否出错中止，整个过程结束后，可输入如下命令，进入安装系统的配置阶段 3、生成新系统的fstab # genfstab -U /mnt \u0026gt; /mnt/etc/fstab 4、进入新系统 # arch-chroot /mnt 四、重启前要做的系统配置 # 设置时区和语言 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc nano /etc/locale.gen # 如下两行前面的#号删除 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 # 保存退出 # 这个命令会根据/etc/locale.gen的配置，生成需要的locale数据 locale-gen 下一步是设置整个系统的首选语言。如果你的设备是服务器之类，只会以 SSH 连接，那么可以设置一个全局中文语言\necho \u0026#39;LANG=zh_CN.UTF-8\u0026#39; \u0026gt; /etc/locale.conf 如果这台机器一般接键盘鼠标，那么这里就设置英文 locale，不然 tty 会显示口口。进了图形界面（比如说 KDE）之后是可以在设置里把用户级别的语言设置成中文的\necho \u0026#39;LANG=en_US.UTF-8\u0026#39; \u0026gt; /etc/locale.conf 设置 hostname # 请把 myarchlinux 换成任何你喜欢的 hostname\necho \u0026#39;myarchlinux\u0026#39; \u0026gt; /etc/hostname nano /etc/hosts # 输入如下三行信息 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyarchlinux.localdomain myarchlinux # 保存退出 设置root用户密码（超级管理员密码） # passwd # 因为当前用户为root，所以设置的是root用户密码，命令运行会提示输入两次密码，两次密码要保持一致。 # 因为系统当前并未设置密码规则，所以无相关限制，确保两次一样即可，此密码权限最高，注意保密。 # 设置好这个密码后，可以在任何用户环境下，通过如下命令进入超级管理员权限，比如安装软件，调整配置等 su # 输入正确的root密码后，可使用超级管理员权限。 建立一个普通用户 # 这个用户用于日常登陆，无管理员权限，确保日常操作不会对系统文件和配置进行更改，组名这里建议使用 wheel\n# 添加新用户 useradd 用户名 -m -G 组名 例如： useradd xyz -m -G wheel # 设置用户登录密码 passwd 用户名 例如： passwd xyz 安装并配置 sudo # pacman -S sudo vi 然后执行 visudo 并将 %wheel 前面的 # 去掉 (可按 x), 去掉之后按 [esc] (ESC 按键） 然后输入 :wq 保存退出。\n现在所有在 wheel 组里面的用户就可以执行 sudo 命令了。\n## Uncomment to allow members of group wheel to execute any command %wheel ALL=(ALL:ALL) ALL 网络配置 # 有线连接，自动获取ip的配置，两种方案任选其一，推荐方案2，进入桌面环境，可以直接管理网络连接 # 方案1： systemctl enable dhcpcd 方案2： systemctl enable NetworkManager 引导配置 # 这一步的配置影响到是否可以正确引导安装完成的基本系统，所以每一步都需要仔细确认：\n系统引导有多个方案配置，根据需要进行选择！\nsystemd-boot 方案 # 龙芯推出的新固件新内核，一个突出的特性是内核支持EFI引导，这让固件直接加载linux内核成为可能。和Grub加载内核相比，系统引导所需要的时间有所缩短，改善了用户体验。具体信息详见：\n如何把你的系统从旧世界迁移到新世界\n指南推荐使用 systemd 内置的 systemd-boot 方案，具体配置方法如下：\n在配置之前，可以使用如下命令确认下分区方案以及挂载情况\ndf # 如果能看到 /mnt 对应 sdb3 以及 /mnt/boot 对应sdb1，说明挂载成功 # 需要说明的是，接下来的操作主要影响 /mnt/boot，也就是EFI分区 1、 安装引导管理程序\n# 如下两个命令，把固件引导系统所需二进制文件和配置文件拷贝到/boot，也就是EFI分区 # 之前安装内核时，内核文件也安装在这个分区上 bootctl --path=/boot install bootctl update 2、配置引导时传递给内核的参数\n# 进入引导配置入口目录 cd /boot/loader/entries # 新建一个引导配置文件 nano arch.conf # 把如下内容输入到arch.conf文件中 title\tArchLinux linux\t/vmlinuz-linux initrd\t/initramfs-linux-fallback.img options\troot=/dev/sdb3 rw loglevel=3 注意：root=/dev/sdb3 是指定根分区的设备名，根据实际情况进行更改，也可以使用uuid名\n3、仔细校对后保存，重启计算机\ngrub 方案 # # pacman -S grub # grub-install /dev/sda (把sda换成你安装archlinux的硬盘名） # grub-mkconfig /boot/grub/grub.cfg 重启电脑后，在EFI启动选项里面选择arch即可。\n五、本机硬盘引导，确认archlinux基本系统安装成功 # 经过上述步骤设置，重启计算机后，可自动加载内核进入archlinux命令行界面\n为了便于后续的图形界面安装，使用root用户，登陆进命令行界面，需要做如下检查：\n1、检查网络连接情况，运行如下命令\npacman -Syy 此命令可测试网络连通情况，也可进一步确认系统的pacman配置是否正确。\n2、安装一些工具软件，对系统信息进行基础检测\n# 安装辅助工具软件包 pacman -S neofetch efivar # 查看系统信息，注意查看gpu是否正确识别 neofetch # 查看efi固件的基本变量 efivar 3、添加仓库\n建议添加下面所有仓库，不要为了省事只添加一部分。\n# 编辑文件 nano /etc/pacman.conf # 查看如下内容，可根据需要进行修改定制 # 行首加#号，表示不使用这个库 [testing] Include = /etc/pacman.d/mirrorlist [core] Include = /etc/pacman.d/mirrorlist [extra] Include = /etc/pacman.d/mirrorlist #[community-testing] #Include = /etc/pacman.d/mirrorlist [community] Include = /etc/pacman.d/mirrorlist [aur] Include = /etc/pacman.d/mirrorlist 编辑完成后，再次运行如下命令\npacman -Syy 可以使用最新的库设置，下载所有生效库的软件包数据库\n六、图形界面组件和程序安装配置 # 1、基本图形环境\n# 安装基本图形系统 xorg pacman -S --needed xorg # 建议确认下如下软件包是否安装 xorg-server xf86-video-amdgpu xf86-video-ati xf86-video-loongson # 安装 gnome 桌面环境 pacman -S --needed gnome gdm # gdm是 gnome 的图形登陆管理器，若准备系统引导直接进入gdm登陆，输入如下命令： systemctl enable gdm # 也可以不重启系统测试下gdm是否正常，可执行如下命令： systemctl start gdm **2、图形登录管理器的配置** # 使用lightdm替换gdm，可以进行如下操作： pacman -S --needed lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settings lightdm-webkit2-greeter systemctl disable gdm # 取消gdm systemctl enable lightdm 3、安装更多的桌面环境\n# 安装 mate 桌面环境 pacman -S --needed mate # 安装 xfce4 桌面环境 pacman -S --needed xfce4 xfce4-goodies 4、中文输入和显示\n# 添加中文字体 pacman -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenhei # 重建字体缓存，安装字体即刻生效 fc-cache -fv # 安装输入法，使用拼音输入 # 方案1：使用ibus输入法引擎 pacman -S ibus ibus-libpinyin pinyin-data # 方案2：使用fcitx输入法引擎 pacman -S --needed fcitx5 fcitx5-chinese-addons ## fcitx 的一些词库 pacman -S fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki # 中文处理的一些配置 # 在桌面环境启用输入法，最直观的办法是启动对应的配置界面 # 这样输入法引擎和输入法都可以进行自由切换 # 方法是双击对应的图标即可，按界面内容添加拼音即刻使用 已xfce桌面环境，启动 ibus 输入法引擎为例：\n5、常用的应用软件\n# 媒体播放，桌面环境已有播放软件，但一些解码组件需要单独安装 pacman -S parole gst-libav x264 libva-vdpau-driver mesa-vdpau libvdpau-va-gl vdpauinfo ffmpeg pacman -S libva-utils libva libva-mesa-driver libva1 # 可使用下面两个工具，查看下解码器支持信息 vainfo vdpauinfo # 浏览器 pacman -S firefox pacman -S chromium # 虚拟机软件 pacman -S qemu-full virt-manager # 文本编辑器 pacman -S --needed kate "},{"id":17,"href":"/applications/lat/","title":"在龙芯3A5000上运行Windows程序","section":"Applications","content":" 文章来源: https://zhuanlan.zhihu.com/p/436405217\n2022-03-18：本文所述操作步骤较为繁琐，另写了一篇操作简单的替代本文内容：\nguee：包教包会：龙芯3A5000上运行任意Windows软件161 赞同 · 25 评论文章 龙芯3A5000是龙芯最新的桌面CPU，它基于龙芯自主设计的LoongArch架构（指令集），性能接近市场主流CPU水平。因为各种操作系统和应用程序都与指令集相关，所以x86架构（指令集）的CPU就不能直接运行ARM架构（指令集）的应用程序，反之亦然。因此诞生了各种各样的二进制（指令）翻译技术，用于跨架构模拟运行其它平台的操作系统和应用程序，各种二进制（指令）翻译技术可以分为软件翻译、硬件翻译、软硬结合的翻译这三大类。我先简述一下二进制翻译技术，然后再给出在UOS和龙芯3A5000上运行任何Windows程序的方法。\n二进制翻译技术简述 # 以软件方式进行二进制（指令）翻译必须存在一个宿主系统，模拟器程序在宿主系统上运行。比如各种游戏模拟器，用来在电脑上玩红白机游戏、街机游戏、PS游戏等，以纯软件的方式构建了一个虚拟的主机环境，让那些游戏程序成为缸中之脑，游戏程序执行的所有指令、请求的所有资源都是由翻译软件模拟出来的，但它以为自己是在真正的主机中运行。\n模拟通用计算机的CPU和相关硬件环境要比模拟游戏主机复杂得多。这方面的代表软件，有开源的可虚拟多种架构的qemu、苹果的rosetta 2、以及微软Windows11在arm上模拟x86和在x86上模拟arm的技术等等。其中qemu可以在多种架构（指令集）之间相互转换，不但只支持动态翻译，而且性能最低，平均运行效率仅为原生性能的5%左右。苹果和微软都是一对一的专用翻译，且与操作系统深度结合，效率较高。\n硬件翻译以Transmeta CPU为代表，它的CPU本身是一种“超长指令字”架构，但在指令译码的阶段，接受的是x86指令，然后把x86指令转换为它自己的指令来运行。这种方式使它的CPU看起来就是一块x86架构的CPU，并且不需要对电脑中的其它硬件进行模拟，各种支持x86指令集的操作系统和应用程序都可以在使用Transmeta CPU的电脑上直接安装运行。Intel/AMD现在的CPU其实也是硬件翻译技术的代表，它们内部是执行的“微码（类似于精简指令集）”，而对于的表现则依然是x86架构的处理器。\n龙芯的LoongArch架构（指令集）则代表了第三个分类，即软件和硬件结合的二进制翻译方式。这种方式既有软件翻译的灵活性，又能接近或达到硬件翻译的效率，兼具二者的优点。龙芯的二进制翻译本质上也是软件翻译，但是对软件翻译中比较耗时的处理提供了专门的硬件指令来加速翻译过程，因此称它为软硬结合的二进制翻译技术。龙芯之所以不使用纯硬件的翻译方式，是因为我们必须建立自主的软件生态体系。如果像Transmeta那样对外表现为x86的CPU，那么它能直接运行的就只有基于x86的操作系统和应用程序，生存状况高度依赖于Intel和微软的态度，因此它虽然在Intel的诉讼中获胜，但却在Intel对市场的操作下惨然离场。\n龙芯的LoongArch架构（指令集）本身是一种独立的，完善的指令系统，可以建立独立于x86/ARM之外的软件生态体系。**龙芯的二进制翻译技术主要是在LoongArch原生软件生态建设的初期，用于补充原生软件的不足，LoongArch架构和龙芯CPU的生存不依赖于Intel/ARM/MS/Google等主导的软件生态。**二进制翻译技术具有单方面的决定权，任何公司都没有理由阻止任何软件以二进制翻译的方式在某种原生不支持的架构上运行。即使软件开发商以检测CPU型号等技术手段阻止运行，那么以软件为主体的二进制翻译技术也能轻松解决这个问题，而固化在CPU硬件中的各种信息和特征则不可能像软件那样在线升级。以软件翻译为主体的二进制翻译，甚至可以针对特定程序把自己模拟成特定的CPU型号。\n即使要翻译的目标架构频繁升级指令集版本，增加新的指令，不断推陈出新，对于龙芯来说，要模拟最新的CPU和指令集，也只是更新一下软件的事儿。而那些需要架构授权的CPU产品，如果没有购买到新版本的架构授权，那就无论如何发布多少个新款CPU产品，都不可能兼容新版架构的新指令。\n龙芯二进制翻译系统的简单结构说明 # 龙芯的二进制翻译系统仍在开发当中，尚未公开技术资料，但当前已经有可以使用的测试版本。我仅仅根据对当前状态分析的结果，简单描述一下它的基本结构如下图，可能不太准确，也不够详细，意会就好。\n基于龙芯LoongArch架构（指令集）的CPU，在运行原生的LoongArch指令集的程序时，不需要二进制翻译，可以直接运行。\n在运行基于其它架构（指令集）的Linux程序时，由龙芯的二进制翻译模块对指令进行转译。程序对Linux的API调用，可以直接由操作系统本身提供支持。\n在运行Windows（x86）的程序时，由于Linux系统本身不能提供Windows系统的API，因此需要使用Wine来提供对Windows API的支持。Wine是给Windows（x86）程序提供虚拟的API接口，而不负责对指令的转译，因此只用wine并不能在非x86的CPU运行Windows程序。在x86的应用程序中，不但程序自身逻辑以及第三方库的二进制代码都是x86指令，而且用于调用Windows API的二进制代码也是x86指令，如果没有二进制翻译，在LoongArch上Windows程序甚至连程序入口的代码都不能执行，也无法调用Window API，程序自身的代码和第三方库就更不可能运行了。\n操作系统API（应用程序编程接口）是由操作系统提供给应用程序的接口，在Linux上运行Windows程序时，假如调用读取文件数据的API，就可以由Wine给应用程序提供这个接口，但接口内部不再是Windows的代码，而是由Wine去调用Linux的相关接口来实现相同的功能，这就是对API的模拟。在应用程序读取到数据之后做的操作，就不在Wine的管辖范围内了。比如程序取得数据后可能加密解密、可能作为图像数据计算对比度、可能作为音频数据计算特殊音效……这些操作可能是由程序自身代码来完成，也可能是调用其它的库文件的接口来实现。这些在Wine支持范围之外的代码，在x86架构（指令集）的CPU上是由CPU直接执行，在LoongArch架构（指令集）的CPU上，就只能由二进制翻译模块转译为LoongArch的指令来执行。\n操作系统和应用程序对CPU指令的使用，是属于ABI（应用程序二进制接口）的一部分，ABI的层级很低，是二进制代码的规范。在基于LoongArch架构的CPU上运行x86程序时，就是由二进制翻译模块来处理对指令的转译，也就是对x86的ABI规范的模拟。不管是Linux还是Windows的应用程序，只要它不是LoongArch原生指令集的，最终都需要经过二进制翻译才能在龙芯的CPU上运行。\n龙芯的二进制翻译模块当前和qemu一样也是只支持动态翻译，但效率比原生的qemu高出一个数量级。将来会支持动、静态结合的翻译模式，也就是程序运行时的动态翻译结果可以保留下来，下次运行相同的程序就直接使用翻译的结果，仅对程序运行时修改自身代码等行为需要动态翻译。这样可以降低翻译的CPU消耗，翻译运行的效率可以大幅度提高，预计运行x86程序可以达到80%的原生效率。这里的80%是指平均80%，而不像某些纯软件的翻译方案仅对特定类型程序翻译效率较高，就笼统地宣传“高效率”。\n在龙芯3A5000上实战运行Windows程序 # 最简单的方式，是在使用3A5000的电脑上安装统信的UOS系统，然后等着UOS系统的应用商店中提供了什么Windows软件，就安装什么软件，可以无障碍，无门槛，无后顾之忧……可是Windows的软件千奇百怪，UOS的应用商店不可能提供所有的Windows软件，那么我们就需要动动小手，自己解决自己的需求。\n目前只有UOS for 3A5000（体验版）系统中集成了龙芯的二进制翻译模块，而龙芯自己的Loongnix为什么反而还没有提供二进制翻译的支持呢？“体验版”这三个字很重要，是否稳定无关紧要。龙芯的Loongnix却是已经正式发布的产品，对于龙芯的行业用户来说，往系统中更新一个还没有开发完成的、可能不稳定的功能模块，大概不是什么喜闻乐见的事情。因此我下面就以UOS为例说明一下如何在龙芯3A5000上运行“任何”的Windows软件，“任何”是指可以尝试任何软件，但不能保证所有软件都能正常运行。\n**UOS中已经集成了龙芯二进制翻译模块，但要运行Windows软件仍然需要一个Wine环境。**UOS本身有多个版本的Wine，有经过深度/统信改良了效率和兼容性的deepin-wine，也有原生的版本，我们要使用deepin-wine。最简单的方式是从UOS应用商店中安装一个由Wine支持的软件，环境就自动配置好了。如果使用Loongnix或其它的系统，就需要手工完成这个过程，可能还需要从UOS复制一些文件和配置，比较麻烦。建议安装的软件是PhotoShop，因为PhotoShop是一个很大很复杂的软件，能够让PhotoShop正常运行的环境，就能让大多数软件正常运行。\n龙芯3A5000运行Windows程序，微信、PS，扫雷绝对不卡15.2 万播放 · 163 赞同视频 ​\nUOS对Wine版软件的组织方式是给每个软件一套单独的Windows环境，也就是说每个软件包中都有配套的Windows、Program Files、ProgramData、User等系统文件夹。这些文件夹和软件本身，都被打包成一个files.7z文件，安装到“/opt/apps”文件夹下以包名命名的子文件夹中。软件首次运行时，files.7z被解压到“/home/用户名/.deepinwine/”文件夹中，并自动配置相关的运行环境。这种方式的好处是每个软件都相对独立，避免因某些共用文件的版本不同导致不能运行，坏处就是会增加许多额外的文件。但实际增加的文件体积并不会很大，因为前面说了Wine只是提供虚拟的API接口，因此包中的操作系统的DLL文件实际都是只有接口没有代码的“代理”版本，每个文件只几KB大小。系统DLL接口的功能是由Wine文件夹中的对应的.so文件来实现的。只有系统DLL之外的，软件自身的以及第三方的DLL文件才是“真实”的DLL文件。\n在安装了PhotoShop（Wine）之后，在“/opt/apps/com.pscs6.deepin/files”文件夹中的files.7z和run.sh是我们需要用到的。\n如果你已经运行过刚刚安装的PhotoShop，那么在“/home/用户名/.deepinwine”文件夹中会有“Deepin-CS6”文件夹，“.deepinwine”是隐藏文件夹，在Linux中文件（夹）名字前面加“.”表示隐藏，在文件管理器中看不到，需要手工在地址栏输入才能打开。它里面的内容如下：\ndosdevices文件夹中的内容是虚拟硬盘盘符和com接口的链接文件，比如“c:”文件就链接到“drive_c”文件夹。“drive_c”文件夹是虚拟的Windodws系统的C盘，里面的内容一看就眼熟：\n如果你要向这个由Wine虚拟的Windows环境中安装软件，或复制绿色软件来运行，就把“drive_c”当成Windows的C盘来用，都往里面复制就行了。其实直接使用PhotoShop的这个Wine环境文件夹也可以，但是为了避免一些麻烦，比如防止意外卸载了PhotoShop之后你放在里面的软件也被一同删除，我们还是最好自己弄个单独的环境。另外说明一下，这是32位的Wine环境，不能运行64位的Windows程序，如果要运行64位的程序，需要手工配置64位的环境，因为UOS还没有提供直接安装的64位Windows程序。\n先把前面在“/opt/apps/com.pscs6.deepin/files”中看到的files.7z复制到“/home/用户名/.deepinwine”文件夹中，然后在files.7z上单击右键，在右键菜单中选择“解压到当前文件夹”。然后“/home/用户名/.deepinwine”下面就会多出一个“files”文件夹，把它改个名字，比如“MyGames”或者像我一样改成“Default”。这个文件夹中的内容和之前“Deepin-CS6”文件夹中的一样，但你不需要在这里运行PhotoShop，因此可以把“/home/guee/.deepinwine/Default/drive_c/Program Files”里面的Adoeb删除掉，节省一些空间。\n再然后可以把下载到的绿色软件或者安装程序等都复制到“/home/guee/.deepinwine/Default/drive_c”中你喜欢的位置，最后把前面看到的“run.sh”复制出来进行一些修改，就可以运行它们了。当然也可以复制下面的内容，保存为一个扩展名为“.sh”的文件，注意要在文件属性的“权限管理”中设置“允许以程序执行”。\n#!/bin/sh #在/home/guee/.deepinwine/下面你的Windows环境所在的子文件夹名。 BOTTLENAME=\u0026#34;Default\u0026#34; #Wine的版本 APPVER=\u0026#34;13.0deepin6~wine5\u0026#34; #要运行的程序的路径，你的drive_c文件夹就是c:/，后是相对于它的路径。 #注意Linux中的路径分隔符是/,而Windows中是\\，这里按照Linux的规则写。 EXEC_PATH=\u0026#34;c:/ali213-AngryBirdschs/AngryBirds.exe\u0026#34; #启动Wine的脚本程序，是Wine自带的。 START_SHELL_PATH=\u0026#34;/opt/deepinwine/tools/run_v4.sh\u0026#34; #大概是这个程序关联的文档类型，这里设置为\u0026#34;\u0026#34;。 export MIME_TYPE=\u0026#34;\u0026#34; #Wine的主程序，这是环境变量，在run_v4.sh这个启动脚本中会使用它。 export APPRUN_CMD=\u0026#34;deepin-wine5-stable\u0026#34; #语言环境设置 export PATCH_LOADER_ENV=\u0026#34;LC_ALL=zh_CN.UTF-8\u0026#34; #也是环境变量设置 export SPECIFY_SHELL_DIR=`dirname $START_SHELL_PATH` DEEPIN_WINE_BIN_DIR=`dirname $APPRUN_CMD` DEEPIN_WINE_DIR=`dirname $DEEPIN_WINE_BIN_DIR` #export WINEPREDLL=\u0026#34;$ARCHIVE_FILE_DIR/dlls\u0026#34; #还是环境变量设置 if [ -n \u0026#34;$PATCH_LOADER_ENV\u0026#34; ] \u0026amp;\u0026amp; [ -n \u0026#34;$EXEC_PATH\u0026#34; ];then export $PATCH_LOADER_ENV fi if [ -d \u0026#34;$DEEPIN_WINE_BIN_DIR\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$DEEPIN_WINE_BIN_DIR\u0026#34; != \u0026#34;.\u0026#34; ];then export DEEPIN_WINE_BIN_DIR fi #启动Wine，并指定由Wine启动的应用程序。 $START_SHELL_PATH $BOTTLENAME $APPVER \u0026#34;$EXEC_PATH\u0026#34; \u0026#34;$@\u0026#34; 上面的“EXEC_PATH”后面的字符串就是你要运行的程序路径，我是从“游侠网”下载了一个绿色版本的《愤怒的小鸟》，其实看到文件夹名中的“ali213”应该就猜到了。这是绿色软件，如果要运行的不是绿色软件而是安装程序，过程也一样，只要把安装程序设置为要运行的程序就可以了。安装完成后，可以再修改一下运行脚本，把“EXEC_PATH”后面的字符串改为安装完成的程序路径。\n安装程序运行时如果在Windows的桌面或开始菜单创建了快捷方式，一般情况下Wine就会自动帮你在UOS的桌面和开始菜单中创建对应的Linux格式的快捷方式。如果Wine没帮你创建，那么也可以自己创建，也就是编写一个扩展名为“.desktop”的文件放在桌面上，或者“/usr/share/applications”中（开始菜单中的程序快捷方式）。只是向“/usr/share/applications”这个文件夹写文件需要root权限，如果没有打开UOS的开发者模式，那么把“.desktop”文件放在“/home/用户名/.local/share/applications”中也可以。\n“.desktop”文件的格式我就不详细说明了，在网上有很多资料。\n至此，就可以尝试在龙芯3A5000的电脑上用二进制翻译功能运行任何的32位Windows程序了。可能成功，也可能运行出错。反正我已经成功安装、运行了很多小软件和游戏，比如7z、帝国时代2、仙剑奇侠传、愤怒的小鸟、CS……等等。并不只是小程序和老游戏可以运行，已经有一些网友测试了一些较大的和较新的软件，可以正常运行的程序很多。\n龙芯3A5000运行Windows程序，微信、PS，扫雷绝对不卡15.2 万播放 · 163 赞同视频 ​\n龙芯3A5000二进制翻译玩Windows版《愤怒的小鸟》3458 播放 · 17 赞同视频 ​\n补充： # 本处补充的内容其实文中已经提到，甚至是黑体加粗的，但总有人假装看不到，那么这里我再集中说一下。\n1. 龙芯二进制翻译和苹果罗塞塔2的异同：\n原理都一样，实现有区别。\n二进制翻译的基本流程是：读取可执行文件-\u0026gt;解析指令流-\u0026gt;把源指令翻译为目标指令-\u0026gt;运行目标指令。中间涉及到寄存器的重定向、源程序（系统）虚拟地址到目标平台的物理地址转换、系统中断的模拟、各种API的调用等等，所有的二进制翻译都是这个样子。\n罗塞塔2只运行苹果自己系统的软件，因此软件对系统API的调用，可以由系统自己提供支持。龙芯如果只运行x86的Linux软件，软件需要的API也可以由系统本身提供，这样和罗塞塔2就没有什么本质区别。\n运行效率方面，罗塞塔2当前优于龙芯的二进制翻译，因为它支持静态翻译，也就是曾经翻译过的代码可以把结果保存起来。对于非动态代码，下次运行时可以运行之前翻译的结果，使部分代码的运行效率与原生效率相当。龙芯的二进制翻译有支持静态翻译的计划，但当前还没有完成，也就是基本上是和qemu差不多的纯动态翻译。但是，龙芯当前的纯动态翻译效率是qemu的10倍，这就是龙芯二进制翻译相关的硬件指令和对x86的一些硬件特性模拟带来的效果。如果继续优化，并且加上静态翻译，理论上最终效率会高于罗塞塔2。\n罗塞塔2只支持从x86到ARM的翻译，龙芯的规划中支持x86、ARM、MIPS、RISC-V到LoongArch的翻译。如果以纯软件方式翻译，其实任何架构之间都可以实现互译，但龙芯的LoongArch当前只对上述架构进行了硬件加速的支持。\n2. Wine和龙芯二进制翻译的关系：\nWine只是提供对Windows API的支持，不包含指令转译的功能，因此在ARM Linux需要ExaGear来提供二进制翻译功能，再加上Wine才能运行Windows程序，在龙芯LoongArch上也是一样，Linux上没有Wine时只能运行其它架构的Linux程序，加上了Wine才能运行Windows程序。\n如果没有二进制翻译，就不可能在非x86架构的CPU上通过Wine运行x86架构的Windows程序。\n3. LoongArch架构和二进制翻译的意义：\nLoongArch在层级上，是与x86/AMD64、ARM、MIPS等并列的，是建设自主软件生态的基础。只有建设了自主软件生态，才能摆脱对国外巨头控制的软件生态的依赖。\nLoongArch不是国内第一个自主设计的指令集，但LoongArch是国内自主设计的指令集中最适合通用计算机的，且有最完善的指令功能设计的，且有最强大的推广和行动能力的。\n二进制翻译功能不是为了“融入国际主流”，而是为了在自主生态建设初期补充原生软件的不足。“融入国际主流”本质上是给国际巨头开疆拓土，然后有被卸磨杀驴的可能性。二进制翻译则完全相反，是在发展自身的同时借用其它软件生态的成果，只会强大自身，而不会反哺对手。\n"}]